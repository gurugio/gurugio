[[TableOfContents]]

= INTEL 64 Architecture & AMD64 Technology 의 기본 개념 =

''' 인텔과 AMD에서 공통되는 기본 개념을 요약했음 (64비트 모드에 대한 대부분의 사항은 인텔과 AMD가 같은 것으로 생각됨) '''

''' 가상화 관련 기능에는 차이점이 있는지 확인 중 '''


== Terminology ==

 * Intel 64 아키텍쳐는 선형 주소를 64비트로 확장하고, 물리 주소를 40비트로 확장한 프로세서 계열을 말한다.
 * 이 새로운 동작 모드의 이름이 IA-32e 모드이다.
 * IA-32e 모드는 두가지 하위 모드를 가진다.
  * 기존의 32비트 소프트웨어를 실행할 수 있는 lagacy 32bit 모드 (64비트 동작 중에서 32비트 운영체제 실행 가능)
  * 64비트 소프트웨어를 실행하는 64bit 모드

 * Intel Virtualization Technology (Intel VT)는 Intel 64와 IA-32 아키텍쳐에서 가상화 기술을 구현한 것이다.
 * 이 기술의 이름이 Virtual Machine Extensions (VMX)라고 한다.
 * 즉, Intel VT가 이름이 아니고 VMX 가 인텔의 가상화 기술의 이름이 된다.
 * VMX는 시스템 소프트웨어가 동작할 수 있는 새로운 layer를 제공하는데 이것을 Virtual Machine Monitor (VMM) 이라고 부른다.
 * 가상화 머신이 동작하는 시스템 레벨이 VMM이다.

== Basic Execution Environment ==

 * Compatibility mode (IA-32e 모드의 하위 모드)
  * 기존의 16비트/32비트 프로그램이 재컴파일 없이 그대로 64비트 운영체제에서도 동작할 수 있도록 해준다.
  * IA-32 아키텍쳐의 32비트 보호 모드의 동작과 거의 동일하게 동작한다. 하지만 Vitrual 8086 모드로 동작하거나 하드웨어 테스크 관리 기능을 사용하는 어플리케이션은 이 모드에서 사용할 수 없다.
  * 32비트 보호 모드 동작과 유사하므로 4GB의 선형 주소만 사용할 수 있고 16비트/32비트 오퍼랜드만 사용할 수 있다. PAE 기능을 사용하면 4GB 이상의 물리 메모리도 사용할 수 있다.

 * 64bit mode
  * 일반 레지스터의 크기가 64비트로 늘어났고 기존 레지스터의 이름에 R을 붙여서 레지스터 이름을 지정할 수 있다.
  * 최대 64비트의 가상 주소 범위를 가질 수 있지만, 실제 프로세서 모델에 따라 그 이하의 주소 범위를 허용한다.
  * 최대 52비트의 물리 주소 범위를 가진다. (PAE 기능을 사용할 때)

 * 64bit Mode의 실행 환경
  * CPUID 명령으로 프로세서가 지원하는 물리 주소 범위를 알아낼 수 있다.
  * 64비트 크기의 일반 레지스터가 16개 있고, 각각 바이트/워드/더블워드/쿼드워드 크기로 사용할 수 있다. 플래그 레지스터도 RFLAGS 레지스터라는 이름으로 64비트 확장되었다.
  * 스택 포인터도 64비트 크기를 가진다.
  * 컨트롤 레지스터도 64비트로 확장되었다. CR8, TRP이라는 새로운 컨트롤 레지스터가 추가되었다.
  * GDTR/IDTR은 10바이트로 확장되었고 64비트 크기의 베이스 주소를 저장할 수 있다. LDTR/TR 레지스터도 64비트 주소를 저장할 수 있도록 확장되었다.

 * 64bit Mode의 메모리 구성
  * 64비트 모드에서는 구조적으로 64비트 선형 주소를 지원하지만 실제 프로세서 구현에 따라 그 이하의 메모리 주소를 지원한다.
  * 선형 주소는 PAE 페이징 메카니즘을 통해서 물리 주소로 맵핑된다.
  * 세그멘테이션은 거의 사용되지 않는다. 특히 CS,DS,ES,SS 레지스터의 세그먼트 주소를 0으로 생각하고, 선형 메모리 공간을 flat 하게 만들어 사용한다. 즉, 세그먼트 레지스터의 값을 무시하고 선형 메모리 주소를 곧 effective 메모리 주소로 사용한다. 세그먼트 주소나 리얼 주소는 더이상 사용되지 않는다.
  * 스택 주소를 사용할 때도 SS 레지스터는 사용되지 않는다. 더이상 SS는 스택 세그먼트를 지정하는 레지스터가 아니게 된다.
  * 예외적으로 FS, GS 세그먼트 레지스터만 베이스 주소를 지정하는데 사용될 수 있다.
  * 16비트나 32비트 주소를 사용하는 프로그램에서는 64비트 레지스터에 주소 값을 저장하고 나머지 비트에는 모두 0을 채운다. 따라서 64비트 모드에서 동작하는 32비트 프로그램은 4GB의 메모리 공간만 사용할 수 있게 된다.
 
 * Canonical Addressing
  * Intel 64 는 64비트의 선형 주소를 정의하고 있지만 프로세서 구현에 따라 그 이하의 주소 크기를 가진다.
  * 초기 IA-32는 Intel 64 아키텍쳐를 지원하지만 48비트의 선형 주소 크기를 지원한다. 48번 비트부터 63번 비트까지는 0이나 1로 채워넣어야 하는데 이런 주소 지정을 Canonical Addressing 이라고 한다. 47번 비트가 0이면 0으로 채워넣고 1이면 1로 채워넣는다.
  * 즉 64비트 선형 주소를 사용하기 위해서, 프로세서가 지원하는 최상위 비트의 값을 프로세서가 지원하지 않는 비트 자리에 채워넣게 된다. 만약 canonical form 이 아닌 주소를 사용하면 general-protection 예외가 발생한다. 스택 주소에서는 stack 폴트가 발생한다.

 * 64비트 모드의 Instruction Pointer
  * 다음에 실행될 명령어의 주소를 가지는 RIP 레지스터는 64비트 크기를 가진다.
  * 64비트 모드에서는 RIP-relative Addressing이라는 새로운 주소 지정 방식을 지원한다. 이 방식에서는 effective 주소를 계산할 때 RIP에 displacement 값을 더하여서 계산하게 된다. 즉, 원하는 데이터나 명령어의 주소를 계산할 때 현재 RIP에서 어느정도 떨어져있는 메모리 위치인지를 계산하는 방식이다.

 * 64비트 모드의 레지스터 오퍼랜드
  * 64비트 일반 레지스터 (RAX, RBX, RDX, RDX, RSI, RDI, RSP, RBP, R8~R15)
  * 32비트 일반 레지스터 (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP, R8D~R15D)
  * 16비트 일반 레지스터 (AX, BX, CX, DX, SI, DI, SP, BP, R8W~R15W)
  * 8비트 일반 레지스터 (AL, BL, CL, DL, SIL, DIL, SPL, BPL, R8L~R15L은 REX라는 prefix와 함께 사용해야 함)
  * 세그먼트 레지스터 (CS, DS, SS, ES, FS, GS)
  * RFLAGS
  * 제어 레지스터 (CR0, CR2, CR3, CR4, CR8)
  * 시스템 테이블 포인터 레지스터 (GDTR, LDTR, IDTR, TR)
  * MSR 레지스터 집합
  * RDX:RAX 쌍으로 128비트 오퍼랜드 지정 가능
  * 그 외의 디버깅 레지스터, MMX/XMM 관련 레지스터

 * 64비트 모드에서 세그멘테이션
  * legacy IA-32 모드에서는 기존의 세그멘테이션과 동일하게 동작함
  * 64비트 모드에서는 CS, DS, ES, SS 레지스터의 값을 항상 0이라고 가정하고 동작한다.
  * 64비트 모드에서 FS, GS만 선형 주소 계산에 베이스 값으로 사용될 수 있다.
  * 코드 세그먼트 디스크립터와 셀렉터는 프로세서의 동작 모드와 권한 레벨을 설정하는데 사용된다. L 이라는 새로운 필드를 만들어서 64비트 모드 동작 중에 L 비트가 0이면 프로세서가 comaptibility 모드로 동작하게 된다. 64비트 모드 동작 중에 L 비트가 1이면 CS.D는 항상 0이 되어야 하고 프로세서는 64비트 주소 크기로 동작한다.
  * 코드 세그먼트 디스크립터의 DPL 필드는 32비트 보호 모드에서와 같이 코드 실행에 필요한 권한 레벨을 검사하는데 사용된다. 
  * 64비트 모드에서는 코드 세그먼트나 데이터 세그먼트의 limit를 체크하지 않는다.

 * 64비트 모드에서의 태스크 관리
  * 사실상 모든 운영체제가 하드웨어 태스크 스위칭 기능을 사용하지 않고 소프트웨어적으로 처리하므로 64비트 모드에서는 하드웨어 태스크 스위칭 기능을 지원하지 않는다.
  * 따라서 JMP, CALL, INTn 등으로 태스크 게이트를 호출하는 것은 GP 예외를 발생시킨다.
  * 64비트 태스크 스테이스 세그먼트 TSS는 계속 존재한다. 400바이트의 크기를 가지며 스택 포인터 값과 인터럽트 스택 테이블 포인터의 값들을 저장한다.
  * 64비트 모드로 전환 후에는 하나 이상의 64비트 TSS를 만들어서 LTR 명령어로 TR 레지스터에 TSS의 주소를 저장해야 한다.
  * 태스크가 전환된 후 스택 포인터는 TSS에 저장된 RSP 값이 된다.
  * SS 레지스터 값은 0이 된다. SS.RPL 값은 전환된 태스크의 CPL 값이 된다.

 * 64비트 모드에서의 인터럽트와 예외
  * 모든 인터럽트/예외 처리 핸들러는 64비트 코드로 작성되야 한다.
  * 인터럽트 번호에 16을 곱해야 IDT 테이블에서 해당하는 인터럽트의 디스크립터를 찾을 수 있다.(32비트 보호모드에서는 8을 곱한다.)
 
 * 함수 인자 전달
  * %rdi, %rsi, %rdx, %rcx, %r8, %r9, 스택  순으로 전달됨
  * http://www.x86-64.org/documentation/abi-0.98.pdf 참고
= 참고 =

 * cppig1995님의 강좌 http://kldp.org/taxonomy/term/3663
 * iamroot 위키 http://www.iamroot.org/wiki/index.php/%EB%8C%80%EB%AC%B8


