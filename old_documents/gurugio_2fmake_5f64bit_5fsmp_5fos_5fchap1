'''64비트-SMP 커널 만들기 - 1장 개발환경'''


----

 * 작성자: 김기오 
 
 * 문서 소개
64비트-SMP 커널 만들기 강좌의 1장

----

 * 작성 일지

2009.2.9 김기오: 1장 작성

----

[[TableOfContents]] 

----

= 개발 환경 =

기본적으로 리눅스기반에서 개발합니다. 가장 편리한 개발 환경은 x86_64 프로세서 기반으로 설치된 리눅스 환경입니다. 이미 모든 개발 툴이 x86_64 프로세서를 지원하므로 Qemu 프로그램 설치 이외에는 개발 툴을 설치할 필요가 없습니다. 하지만 아직까지 i386 기반 환경이 더 보편적이므로 윈도우에서 Cygwin기반으로 동일한 툴을 설치해서 사용할 수 있도록 각 프로그램의 소스를 컴파일하는 방법도 간단하게 소개합니다. 우리는 개인 사용자에게 무료로 사용할 수 있도록 공개된 툴만을 사용하겠습니다.

작성한 커널을 실행하기 위해서 듀얼코어 피시를 따로 살 필요없이 가상머신을 이용해서 개발하는 것이 좋습니다. 일단 돈이 적게 들어간다는게 제일 큰 이유입니다. 그리고 테스트하기가 편하고 빨라서 개발하는데 시간도 적게 들어갑니다. 퇴근하고 얼마 안되는 시간동안 공부하는데 개발 환경이 불편하고 느리면 절대 공부 못합니다.

== Qemu 설치 ==

가상 32비트 피시 환경을 제공해주는 소프트웨어는 많습니다. 잘 알려지지 않는 소프트웨어부터 Vmware와 같이 유명한 것도 있습니다만 우리는 64비트이면서도 듀얼코어 환경을 제공해주는 가상 머신 소프트웨어를 필요로 합니다. 최근에는 Vmware도 64비트, 듀얼코어 환경을 제공해주고 있습니다만 유료 소프트웨어이고 평가판의 사용 기간도 정해져있어서 사용하기 어렵습니다. 그래서 Qemu라는 공개 소스 소프트웨어를 사용하겠습니다.

Qemu는 2005년부터 개발되어서 개발 기간이 긴 편은 아니지만 ARM, MIPS 같은 임베디드 프로세서의 가상 머신도 지원하고 있고 윈도우와 리눅스에서 똑같이 사용할 수 있는 장점이 있습니다. 비록 Vmware같은 상용 소프트웨어에 비해 느리게 동작하지만 64비트, 듀얼코어 환경에 대한 지원이 잘 되어 있어서 덩치가 작은 운영체제를 동작시키기에는 전혀 무리가 없습니다. 특히 Qemu는 프로세서의 모든 기능을 완전히 가상화시켜줍니다. Vmware는 운영체제를 실행시킬 때 자신이 동작하는 실제 프로세서에서 실행시키는 방식으로 환경을 제공합니다. 따라서 속도가 빠르지만 완전한 가상 환경을 제공하는게 아니라 Vmware가 설치된 환경에 따라 제공하는 가상 머신이 달라집니다. 하지만 Qemu는 32비트 x86 환경에 설치되었어도 64비트 x86이나 ARM 등의 가상 환경을 제공할 수 있습니다. 그래서 Qemu는 완전한 가상 환경을 제공한다고 이야기합니다.

특히 놀라운 것은 Vmware 환경에 설치된 리눅스 안에서 Qemu가 동작한다는 것입니다. 가상 환경에 설치된 OS에서 또다시 가상 환경을 실행할 수 있다는 놀라운 장점이 있습니다. Qemu가 모든 가상 환경을 소프트웨어로 구현했기 때문에 가능한 것입니다. 

Qemu의 공식 홈페이지의 주소는 http://bellard.org/qemu/ 입니다. 공식 홈페이지에서는 소스 리눅스용 코드와 리눅스용 바이너리 파일만을 제공하고, 윈도우나 Mac OS X, 솔라리스용 패키지는 Qemu 프로젝트에 공헌하고 있는 개인 개발자들의 홈페이지에서 제공하고 있습니다. 

홈페이지에서 qemu 소스나 바이너리 패키지를 받아서 설치합니다. 소스를 컴파일하기 위해서는 Qemu의 홈페이지 문서 중에 컴파일 관련 챕터 http://bellard.org/qemu/qemu-doc.html#SEC76 를 참고합니다. ./configure 와 make 명령만으로 쉽게 컴파일할 수 있습니다. 만약 우분투 배포판을 사용하고 있다면 패키지 관리자에서 qemu를 찾으면 쉽게 설치할 수 있습니다.

주의할 것은 0.9.x 버전의 qemu는 멀티코어 동작에 문제가 있다는 것입니다. 반드시 0.10.x 이상 버전을 설치해서 사용해야 합니다.

Qemu의 다운로드 페이지 http://bellard.org/qemu/download.html 에 접속하면 윈도우 Qemu를 받을 수 있는 링크 주소가 써있습니다. 그런데 윈도우용 Qemu 제공 사이트에 들어가면 업데이트를 안한다고 되어있고 다른 사이트의 링크를 알려주고 있습니다. 2009년 2월 9일 현재 http://homepage3.nifty.com/takeda-toshiya/qemu/ 주소에 접속하면 2008년 12월 29일 버전의 Qemu를 받을 수 있습니다. 윈도우용 Qemu의 실행은 간단합니다. 설치도 필요없고 압축을 풀고 적당한 디렉토리로 복사하기만 하면 됩니다.
== Qemu 실행 ==

리눅스 환경에서 qemu가 설치되면 다른 설치 경로를 지정하지 않았을 때 /usr/bin/ 디렉토리에 qemu-system-i386, qemu-system-x86_64 실행 파일이 저장된다. 윈도우 환경에서는 qemu 패키지의 압축 파일을 풀어놓은 곳이 설치 경로가 된다.

i386이나 x86_64용 가상 환경이 실행되기 위해서는 바이오스 파일이 필요하다. 실제 피시의 바이오스와 같은 역할을 한다고 생각하면 된다. 물론 임베디드 환경에는 바이오스가 없으므로 ARM 등의 임베디드 프로세서는 바이오스를 생각하지 않아도 된다. 윈도우 환경에서는 이 바이오스 파일이 qemu 패키지에 함께 저장되어 있으므로 쉽게 찾을 수 있지만 리눅스 환경에서는 설치 경로에 따라 달라진다. 우분투 배포판에서 패키지 관리자를 이용해서 설치한 경우 /usr/share/qemu 디렉토리에서 바이오스 파일을 찾을 수 있고, 소스를 컴파일해서 설치한 경우 소스 디렉토리안의 pc-bios 디렉토리에 저장되어 있다. 바이오스 파일도 여러가지가 있는데 일반 PC용 바이오스인 bios.bin 파일을 기본으로 사용한다.

qemu를 실행하기 위해서는 바이오스 파일의 경로, 메모리 크기, 부팅 장치 등의 옵션을 지정해주어야 한다.

먼저 윈도우 환경에서의 실행 옵션이다.

qemu-system-x86_64.exe -L . -m 512 -fda ..\src64_v0.1\floppy.img -boot a -smp 2

리눅스에서는 다음과 같이 실행한다. 리눅스에서는 바이오스 파일의 경로를 따로 지정할 필요가 없다.

qemu-system-x86_64 -m 128 -fda ./floppy.img -boot a -smp 2

다음은 각 옵션의 설명이다.

 * -L . : 롬 바이오스와 키맵 설정을 현재 디렉토리에서 찾음
 * -m 512 : 가상 환경의 물리 메모리가 512MB
 * -fda ./floppy.img : 플로피 디스크 이미지 파일의 경로와 파일 이름
 * -boot a : 플로피 디스크로 부팅함
 * -smp 2 : 프로세서가 2개있는 SMP 머신

실행 확인을 위해 CaOS v0.1 패키지안에 있는 floppy.img 파일을  부팅해보면 다음과 같은 화면이 출력된다. 실행 화면은 qemu가 설치된 운영체제에 상관없이 동일하다.

attachment:gurugio/make_64bit_smp_os/pic_1-1.jpg


Qemu의 중요한 기능 중 하나가 모니터링 기능이다. 가상 머신이 실행하는 중간에 가상 머신을 정지시키고 모니터링 모드로 변환하면 현재 하드웨어 레지스터 값과 메모리 값 등을 확인할 수 있다. 모니터링 모드로 변환하기 위해서는 qemu가 실행하는 중간에 CTRL+ALT+2 버튼을 순서대로 같이 눌러준다. 그러면 다음과 같은 창의 출력된다. 다음 그림은 모니터 콘솔에서 info cpus 명령을 내려본 결과이다. 다시 가상 머신으로 돌아가려면 CTRL+ALT+1 버튼을 누른다.

attachment:gurugio/make_64bit_smp_os/pic_1-2.jpg

모니터 콘솔에서 입력할 수 있는 명령들을 소개한다.

 * info registers : 레지스터 값 출력
 * x/fmt addr : addr 주소의 가상 메모리 값 덤프
 * xp/fmt addr : addr 주소 물리 메모리 값 덤프
  * fmt 포맷의 양식 `/{count}{format}{size}'
  * count : 출력할 값의 갯수
  * format : x (hex), d (signed decimal), u (unsigned decimal), o (octal), c (char) or i (asm instruction).
  * size : b (8 bits), h (16 bits), w (32 bits), g (64 bits).
  * 데이터 확인 사용예 : xp /20x 0x100000 -> 4바이트씩 20개 출력
  * 데이터 확인 사용예 : xp /20gx 0x100000 -> 8바이트씩 20개 출력
  * 코드 디버깅 사용예: xp /20hi 0x9000 -> 16비트로 어셈블된 20개의 명령어 출력

특히 부트로더를 만들거나 프로세서를 초기화하는 코드를 만들 때, 프로그램이 제대로 동작하는지를 확인하기 위해서 콘솔 모드를 많이 사용한다. 프로세서 초기화가 끝나고 C 언어로 코드를 작성할 수 있는 단계가 되면 디버깅 메시지를 출력해보면서 디버깅할 수 있지만 그 이전까지는 프로세서 레지스터의 값이나 메모리 값을 일일이 확인하면서 디버깅해야 한다.

예를 들어 부트로더를 작성해서 플로피 디스크 이미지의 첫 섹터에 저장했는데 시스템이 정상적으로 동작하는지 확인하고 싶을 때가 있다. 비디오 메모리에 직접 문자를 출력하는 방법도 있고, 모니터 콘솔에서 부트로더가 저장된 위치의 메모리 값을 출력해볼 수도 있다. 물리 메모리에 저장된 코드를 출력해보기 위해서는 xp 명령을 사용하면 되고 부트로더 코드가 16비트이고 시작 주소가 0x7C00 이므로 다음 명령을 사용하면 된다.

 * xp /20hi 0x7c00

다음 그림은 모니터 콘솔에서 부트로더 코드를 출력해본 화면이다.


attachment:gurugio/make_64bit_smp_os/pic_1-3.jpg


== nasm 설치 ==

리눅스에서 사용할 수 있는 어셈블러는 여러 가지가 있지만 문법이 제일 간단한 nasm (Netwide Assembler)를 사용한다. 홈페이지 주소는 http://www.nasm.us/  이고 2009년 2월 10일 현재 2.05.01 버전까지 개발되었다. 2.0 버전부터 64비트 코드를 지원하므로 반드시 2.0 이후 버전을 설치해야 한다.

대부분의 배포판에서 nasm 패키지를 제공하지만 2.0 이전 버전의 패키지를 제공하는 경우가 있으므로 현재 배포판의 버전을 잘 확인하자. 만약 2.0 이전 버전이라면 소스를 받아서 설치한다.

nasm의 소스는 매우 간단하고 다음 명령으로 컴파일하면 /usr/local/bin 디렉토리에 nasm 파일이 설치된다.

 * ./configure
 * make
 * make install

nasm은 설치된 환경에 상관없이 옵션에 따라 16비트, 32비트, 64비트 코드를 만들 수 있다. 커널 개발에서 어셈블리 코드를 사용할 경우는 부트로더를 만들 때와 프로세서를 직접 제어하는 코드를 만들 때이다. 부트로더를 만들 때는 16비트 코드로 시작했다가 32비트 코드로 만들고, 다시 64비트 코드로 전환되어야 한다. 프로세서가 16비트 코드로 동작할 때를 리얼모드라고 부르고, 32비트일 때는 보호모드, 64비트의 경우에는 롱모드라고 부른다.

부트로더를 만들 때는 16비트/32비트 바이너리 코드로 만들어야 한다. 16비트나 32비트 바이너리 코드를 만들 때는 아무런 옵션도 지정하지 않고 소스 코드 내에서 16비트 코드인지 32비트 코드인지를 표시해주어야 한다. 실행 방법은 다음과 같다.

 * nasm -o <이미지 이름> <소스 이름>

C로 작성된 코드와 함께 링크되는 어셈블리 코드를 만들기 위해서는 64비트 elf 포맷의 오브젝트 파일을 만들어야 한다. 이렇게 특정 포맷을 지정하기 위해서는 -f 옵션을 사용한다. 실행 방법은 다음과 같다.

 * nasm -f elf64 -o <이미지 이름> <소스 이름>

== 64비트 컴파일러 설치 ==

64비트 프로세서에서 동작하는 프로그램을 만들어야 하므로 당연히 64비트 코드를 만들어주는 개발 툴을 사용해야 한다. 만약 64비트용 배포판을 설치해서 사용하고 있다면 64비트용 개발 툴이 설치되어 있겠지만 프로세서가 64비트이더라도 32비트용 리눅스를 설치했다면 32비트 코드를 생성하는 개발 툴이 설치되어 있다. 64비트 코드를 만들기 위해서는 개발툴을 직접 설치해서 사용해야 한다. 다행이 32비트 리눅스상에서 32비트 개발툴을 가지고도 컴파일 옵션을 바꿔서 64비트용 개발툴을 만들 수 있다. 결론만 말하자면, 32비트 머신에서 동작하지만 64비트 코드를 출력해주는 크로스 컴파일러를 만들어야 한다.

CaOS를 개발에 사용되는 툴은 gcc, ld, objcopy, nm, objdump, nasm 등이다. nasm과 gcc, objcipy 등 대부분의 툴은 32비트용이라 해도 옵션에 따라 64비트 코드를 만들어주지만 ld만큼은 32비트용을 그대로 이용할 수가 없다.  ld, objcopy 등 gcc 이외의 툴들은 binutils라는 패키지로 묶여서 제공되므로 binutils와 gcc 패키지를 받아서 컴파일한다.



=== 64비트 GCC 설치 ===

'''현재 확인한 바로는 gcc 4.3.2 이상의 버전만이 -mcmodel=large 옵션을 처리할 수 있다고 함, 반드시 4.3.2 이상 버전을 사용할 것'''

먼저 GMP (GNU Multiple Precision Arithmetic) 라이브러리를 설치해야 한다. http://ftp.gnu.org/gnu/gmp 에 접속하면 gmp-4.2.1.tar.bz2 를 받을 수 있다. gcc 버전에 따라 요구하는 gmp 버전이 다를 수 있으므로 꼭 gmp-4.2.1 을 사용한다. 압축을 풀고 다음 명령으로 gmp 라이브러리를 /usr/cross 디렉토리에 설치한다.

 * configure --prefix=/usr/local/cross
 * make
 * make check
 * make install
 * 정상적으로 설치가 끝나면 ldconfig 명령을 실행해줄 것

gmp를 설치한 후에 http://gcc.gnu.org 에서 gcc-4.3.2.tar.gz를 다운받는다. 압축을 풀고 다음 명령으로 gcc를 설치한다.

 * ./configure --target=x86_64-pc-elf --prefix=/usr/local/cross --disable-nls --enable-languages=c,c++  --with-newlib --without-headers --with-gmp-lib=/usr/local/cross/lib --with-gmp-include=/usr/local/cross/include
 * make all-gcc
 * make install-gcc

새로 설치한 gcc는 순전히 CaOS를 컴파일하기 위해서만 사용된다. CaOS에는 stdc 라이브러리 등의 라이브러리를 전혀 사용하지 않고 온전히 자기 자신만 컴파일되고 링크되기 때문에 gcc를 설치할 때도 gcc의 실행 파일만 있으면 된다. 따라서 --with-newlib --without-headers 옵션으로 현재 배포판에 설치된 라이브러리를 사용하지 않도록 한다. gmp 라이브러리의 경로만을 지정해주면 컴파일할 수 있다. 원래 gcc 패키지를 업그레이드하는 일은 복잡한 옵션이 필요하지만 외부 라이브러리를 전혀 참조하지 않는 gcc가 필요하므로 이렇게 간단하게 컴파일해서 사용할 수 있다.

마지막으로 /usr/local/cross/bin 디렉토리를 열어보면 x86_64-pc-elf-gcc 파일을 확인할 수 있다.

{{{
혹시 configure 실행 중에 mpfr.h 헤더 파일을 찾지 못하는 에러가 발생하면 MPFR 라이브러리를 설치하면 된다. 우분투의 경우  apt-get install libmpfr-dev 명령으로 쉽게 라이브러리를 설치할 수 있다.
그 외의 배포판은 http://www.mpfr.org/ 에서 소스를 찾아서 빌드한다.
}}}
=== 64비트 binutils 설치 ===

binutils의 소스 패키지는 http://ftp.gnu.org/gnu/binutils/ 에서 받을 수 있다. 이 사이트에서 binutils-2.19.tar.gz 파일을 받아서 압축을 풀고 다음 명령을 실행해서 컴파일한다.

 * ./configure --prefix=/usr/cross --target=x86_64-pc-linux --enable-64-bit-bfd --disable-shared
 * make configure-host
 * make LDFLAGS="-all-static"
 * make install

정상적으로 컴파일이 완료되면 /usr/cross/bin 디렉토리에 x86_64-pc-linux-ld 등의 프로그램들이 설치된다.


== 참고 자료 ==

 * http://wiki.osdev.org/GCC_Cross-Compiler_for_x86_64
 * http://kkamagui.tistory.com/507
 * http://wiki.osdev.org/Creating_a_64-bit_kernel
