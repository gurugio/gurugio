
'''64비트-SMP 커널 만들기 - 6장 디스크립터 테이블과 인터럽트 처리'''


----

 * 작성자: 김기오 
 
 * 문서 소개
64비트-SMP 커널 만들기 강좌의 6장

----

 * 작성 일지

2009.2.27 김기오: 작성 시작


----

[[TableOfContents]] 

----

= 디스크립터 테이블과 인터럽트 처리 =


== GDT 테이블 구현 ==


부트로더에서 보호모드 전환을 위해 GDT 테이블을 만들었지만 이것은 부팅을 위해 임시로 만들어서 사용한 것이었다. 물론 그냥 사용할 수도 있지만 메모리 관리를 편리하게 하기위해 부팅 메모리 할당자를 이용해서 메모리를 할당받고 이전에 사용하던 GDT를 복사한다. 그리고 GDTR 레지스터에 새로운 GDT의 주소와 크기를 써주면 새로운 GDT를 만드는 작업은 끝난다. 참고로 부트로더에서 사용된 모든 메모리 영역은 커널의 부팅이 시작된 이후로 모두 자유 페이지 프레임으로 취급되서 다시 사용되지 않는다. 커널의 독립성을 위해서 부트로더의 데이터를 최대한 사용하지 않아야 한다.

GDT를 만든 후에는 TSS도 만들어주어야 한다. 하나의 페이지 프레임을 할당받고 GDT에서 5~6번 엔트리를 TSS에 대한 디스크립터로 만든다. 마지막으로 LTR 명령어로 TR 레지스터에서 TSS 디스크립터의 인덱스를 저장한다. TSS는 i386에서 태스크 스위칭을 위해 사용되었는데 x86_64에서는 태스크 스위칭을 완전히 소프트웨어적으로 처리해야 한다. x86_64 프로세서의 롱모드에서 TSS는 프로세서의 권한 레벨이 바뀔 때마다 사용할 스택의 주소와 인터럽트가 발생했을 때 인터럽트 전용으로 사용될 스택의 주소 등에 대한 정보를 가지고 있다. 사용 방법은 i386 프로세서와 완전히 다르지만 반드시 하나의 TSS를 만들어야 한다. 일단 지금은 TSS를 위한 메모리만 할당받고 후에 프로세스 관리 기능을 구현하면서 TSS에 필요한 내용을 기록한다.


== IDT 테이블 구현 ==


idt. 파일의 idt_init 함수가 IDT 테이블의 생성 및 예외 처리 핸들러 등록을 담당한다. 프로세서의 예외를 처리하기 위한 IDT 테이블을 구현한다. 원래 보호모드에 진입하기 위해서는 IDT 테이블도 구현해야 하는데 인터럽트를 활성화하지 않거나 예외가 발생할 일이 없다면 IDT 테이블이 없어도 보호모드와 롱모드에 진입이 가능하다. 

먼저 IDT 테이블이 저장될 하나의 페이지를 할당받는다. GDTR레지스터와 마찬가지로 IDTR 레지스터에도 테이블의 시작 주소와 크기를 써주고 프로세서의 예외를 처리하는 핸들러의 디스크립터를 기록한다. 나머지 디스크립터에는 디폴트 핸들러 _ignore_isr의 포인터를 기록한다.

프로세서 예외 핸들러는 어셈블리로 구현되어 있다. 인터럽트나 예외가 발생해서 핸들러가 호출되기 전에 먼저 하드웨어 컨텍스트를 스택에 보존해놓고 핸들러가 실행되야 하는데 C 언어로는 스택 처리를 구현할 수 없기 때문이다. 또한 예외가 발생했을 때 프로세서가 자동으로 스택에 에러 코드를 저장해주는데 이것을 읽기 위해서도 어셈블리 처리가 필요하다. 따라서 예외 처리에 대한 진입 코드는 except_entry.asm 파일에 구현되고, 실제로 예외를 처리하는 핸들러는 except_handler.c 파일에 구현된다.


== 예외 처리 ==


x86_64 프로세서는 0~19까지의 예외를 가진다. IDT 테이블을 만들고 IDTR 레지스터를 설정한 후 다음과 같이 각 예외의 핸들러를 IDT 테이블에 등록한다. 예외의 종류에 따라 트랩/인터럽트/시스템 게이트 등으로 나뉘는데 이것은 인텔 프로세서가 정의한 특성에 따른 것이므로 세부 사항은 인터럽트 메뉴얼을 확인한다. 각각의 예외에 따라 조금씩 특성이 다르므로, 디스크립터를 설정할 때도 조금씩 값이 다르다. 따라서 트랩은 set_trap_gate 함수로, 시스템게이트는 set_system_gate, 인터럽트 게이트는 set_intr_gete 함수로 구분해서 등록한다. 

이 핸들러는 한번 정하면 바뀔 일이 없으므로 굳이 세세하게 처리할 필요는 없지만, 페이지 폴트 등 몇개의 예외는 매우 자주 사용되므로 주의할 필요가 있다.

{{{
 72     // processor exception handlers
 73     set_trap_gate(0, _divide_error);
 74     set_trap_gate(1, _debug);
 75     set_intr_gate(2, _nmi);
 76     set_system_gate(3, _int3);
 77     set_system_gate(4, _overflow);
 78     set_system_gate(5, _bounds);
 79     set_trap_gate(6, _invalid_op);
 80     set_trap_gate(7, _device_not_available);
 81     set_trap_gate(8, _doublefault_fn);
 82     set_trap_gate(9, _coprocessor_segment_overrun);
 83     set_trap_gate(10, _invalid_TSS);
 84     set_trap_gate(11, _segment_not_present);
 85     set_trap_gate(12, _stack_segment);
 86     set_trap_gate(13, _general_protection);
 87     set_intr_gate(14, _page_fault);
 88     set_trap_gate(16, _coprocessor_error);
 89     set_trap_gate(17, _alignment_check);
 90     set_trap_gate(18, _machine_check);
 91     set_trap_gate(19, _simd_coprocessor_error);
}}}


현재 v0.05 버전에서는 예외 처리가 완전히 구현되지 않았다. 현재까지는 예외가 발생하면 에러 값과 예외를 발생시킨 명령어의 선형 주소가 출력되도록만 구현했다. 페이지 폴트와 디버그 예외만을 구현할 예정이다.



== 하드웨어 인터럽트 처리 ==


=== PIC8259A 초기화 ===


프로세서 내부에서 발생하는 예외들은 프로세서가 미리 정하고 있지만, 프로세서 외부에서 요청되는 인터럽트는 각 인터럽트마다 어떤 벡터를 할당해야 하는지 커널 개발자가 직접 정해야 한다. x86_64에서는 외부 인터럽트를 처리하는 PIC를 프로세서 내부에 가지고 있고 Local APIC (Advanced PIC)라고 부른다. Local APIC는 주로 프로세서간의 통신을 위한 인터럽트와 프로세서 내부의 타이머를 위해 사용되고, 외부 장치를 위한 PIC는 PIC8259A칩이나 IO APIC를 이용한다. 

아직까지는 IO APIC에 대한 자료를 찾기가 어렵고, IO APIC를 사용해야 할 만큼 다양한 장치를 사용할 것이 아니기 때문에 현재까지는 PIC8259A 칩을 초기화하여 외부 장치의 인터럽트를 처리한다. pic8259.c 파일의 pic8259_init 함수는 8259A 칩의 입출력 포트에 설정 값들을 전송해서 동작 방식을 설정한다. 

2개의 8259A 칩이 연결되어서 사용되는데 이런 동작 방식을 cascade 방식이라고 한다. 하나의 칩은 마스터, 하나는 슬레이브로 설정되어서 슬레이브 칩의 출력핀이 마스터의 IRQ#2 핀에 연결되어 있다. 슬레이브에 연결된 장치에서 인터럽트가 발생하면 마스터의 IRQ#2 핀으로 신호가 전달되고 마스터가 슬레이브의 IRQ 벡터 번호를 알아내서 프로세서에게 알려준다. 결국 2개의 8259A 칩을 사용하지만 최대 15개의 인터럽트를 지원하게 된다. 8259A의 프로그래밍시에 주의할 것은 소스 코드에 있는 코드의 순서를 바꾸면 안된다는 것이다. 8259A 칩은 입출력 포트가 1개이므로 전달되는 값의 순서에 따라 설정되므로 이 순서를 잘 따라야 한다.

1. 0x11 값 전달: 칩의 초기화를 시작한다는 표시
2. 벡터 번호 전달: 칩이 사용할 벡터 시작 번호 설정
3. cascade 설정: 마스터와 슬레이브의 연결 상태 설정
4. 동작 모드 설정: 8086모드, 수동 EOI 전송 등의 동작 방식 설정
5. IRQ 마스킹 상태 설정: 허용할 IRQ는 0, 금지할 IRQ는 1로 설정

0x11 값을 쓰는 순간부터 3개의 값을 전달할 수 있다. 1~4번 동작이 8259A칩의 초기화 과정이고, 마지막의 IRQ 마스킹 상태는 초기화와 상관없이 언제든지 설정할 수 있는 값이다.


=== 인터럽트 핸들러 등록 ===


x86계열 프로세서는 예외와 인터럽트의 구분이 없이 하나의 IDT 테이블에 예외 처리 핸들러와 인터럽트 핸들러를 등록해서 사용한다. 따라서 irq_init 함수에서 IDT 테이블에 인터럽트 핸들러의 엔트리 함수들을 등록한다. IDT의 0~19 디스크립터는 프로세서의 예외 처리 핸들러가 등록되고 IRQ는 IDT의 0x20~0x2F 디스크립터에 등록된다. 즉 0번 IRQ는 IDT 테이블의 0x20 번 항목에 등록된다.

시스템에 몇개의 장치가 있고, 각각이 어떠한 특성을 가지는지를 세세하게 확인하려면 바이오스의 데이터를 읽어야 하지만 CaOS에서는 키보드와 타이머 등 최소한의 장치만을 사용할 것이므로 최대 16개의 IRQ만을 처리할 수 있도록 irq_handler 라는 함수 포인터의 배열을 만든다. 그리고 인터럽트 핸들러의 엔트리 포인터로 사용될 16개의 어셈블리 함수를 미리 만들어놓는다. 사용할 장치를 초기화할때는 irq_handler 배열에 핸들러 함수 포인터를 등록하기만 하면 되고 어셈블리 함수를 따로 만들 필요가 없으므로 간편하게 핸들러를 등록할 수 있게 된다. 예외 처리와 다르게 장치 인터럽트 핸들러는 동적으로 등록하거나 해지할 수 있어야 하므로 이렇게 엔트리 함수를 미리 만들어놓는다. 각각의 엔트리 함수들은 모두 handle_irq 함수를 호출하고 함수 인자로 IRQ 번호를 넘긴다. 그러면 handle_irq 함수는 함수 인자를 가지고 irq_handle 테이블에서 해당 핸들러를 호출한다. 다시 정리하면 IRQ는 다음과 같은 순서로 처리된다.


1. 장치 초기화 과정에서 인터럽트 핸들러 handle_x 등록
2. IRQ 번호 x가 요청됨
3. 프로세서가 자동으로 IDT[0x20+x] 을 읽고 _irq_x 어셈블리 함수 호출
4. _irq_x 어셈블리 함수에서 handle_irq 호출
5. irq_handler 테이블에서 x번째 함수 포인터 호출
6. handle_x 실행


== 참고 자료 ==


 * 인터럽트 처리
  * 리눅스 커널의 인터럽트 처리 http://asmlove.co.kr/wiki/wiki.php/gurugio/linux_do_irq
  * 기본적인 인터럽트 처리 요령 http://wiki.osdev.org/Interrupts




