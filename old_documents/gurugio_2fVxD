''' example : firstvxd.zip, vxdmessage.zip, sheelmsg.zip, svdexecute.zip, vxdbeep.zip'''
attachment:VxD_examples.zip

= Iczelion's VxD tutorials =

''처음 VxD를 공부하면서 번역한 것이라 오류가 많을 것입니다.''

''반드시 원본 문서와 같이 보시면서 읽어보실 것을 권합니다.''

''자유롭게 사용하셔도 좋습니다만 어셈러브 이름은 지우지 말아주시길 바랍니다.''

[[TableOfContents]]

== Virtual Device Driver Basics ==
Windows 95 는 최고 레벨인 ring 0에서 동작하는 멀티 스레딩 운영체제이다. 모든 응용 프로그램은 최하위 레벨인 ring 3에서 동작한다. 따라서 응용 프로그램은 시스템에서 할 수 있는 일들이 제한되어 있다. 따라서 그것들은 CPU의 특권층 명령어나 I/O 포트를 직접 제어하는 등의 일은 할 수 없다. 당신은 분명 이 세가지 큰 시스템의 구성 요소에 대해 알 것이다 : gdi32, kernel32, user32. 당신은 아마 그런 중요한 코드들은 ring 0에서 동작해야 한다고 생각할 것이다. 하지만 사실 다른 응용프로그램들 처럼 ring 3에서 동작한다. 말하자면 계산기나 땅따먹기 게임와 마찬가지 권한을 가지고 있다는 것이다. 시스템의 진짜 중요한 부분은 VIRTUAL MACHINE MANAGER (VMM)과 VIRTUAL DEVICE DRIVER (VxD) 가 제어한다. 

이 모든 것들은 도스가 문제를 복잡하게 만들지 않았다면 생겨나지 않았을 것이다. WINDOWS 3.x 시대에 시장에는 쓸모있는 DOS 프로그램들이 수없이 많았었다. 보통의 윈도우즈 프로그램들처럼 이들을 사용할 수 있어야 WINDOWS 3.x 가 상업적으로 실패하지 않았을 것이다. 

이 딜레마는 해결하기 쉽지 않다. 도스와 윈도우즈의 프로그램들은 서로 너무나 다르다. 도스 프로그램들은 키보드, 시피유, 메모리나 디스크 등 시스템의 모든 것을 자기가 가지고 있다고 생각하기 때문에 곤란하다(BAD라고 써있음). 윈도우즈 프로그램들은 (그 당시에) 비선점형 멀티 태스킹에서 돌아가는 데 만해 도스 프로그램들은 다른 프로그램들과 같이 동작할 줄을 몰랐다. 말하자면 모든 윈도우즈 프로그램들은 GetMessage나 PeekMessage등을 통해 서로 다른 프로그램에게 양보할 수 있었지만 도스는 아니었다. 

해결책은 다른 모든 윈도우즈 프로그램들은 SYSTEM VIRTUAL MACHINE 이라 불리는 가상 머신에서 돌아가고 각 도스 프로그램들은 가상 8086 머신에서 돌아가게 하는 것이었다. 윈도우즈는 각각의 가장 머신들에게 라운드 로빈 방식으로 시피유 시간을 줘야 한다. 그래서 윈도우즈 3.x에서 프로그램들은 cooperative(비선점형) 멀티 태스킹을 사용하지만 가상 머신들은 선점형 멀티 태스킹을 사용하게 되었다. 

가상 머신이 무었인가? 가상 머신은 프로그램에 의해 유일하게 생성된 허상이다. 가상 머신은 프로그램이 자신이 진짜 머신인 것처럼 프로그램에게 응답한다. 그래서 프로그램은 자신의 가상 머신에서 동작하는 것인지도 모르고 신경쓰지도 않는다. 가상 머신이 프로그램에게 완벽히 진짜 머신인 것처럼 응답하면 진짜 머신처럼 생각되어지는 것이다. 

당신은 가상 머신과 소프트웨어의 인터페이스를 API의 한 종류처럼 생각해도 좋다. 이 특별한 API는 인터럽트와 BIOS 함수 I/O 포트들로 이루어져 있다. 어쨌든지 윈도우즈가 이 API를 완벽하게 흉내만 낸다면 가상 머신에서 돌아가는 프로그램은 진짜 머신에서 돌아가는 프로그램과 완전히 동일한 동작을 한다. 

이렇게 VMM과 VxD가 등장하게 되는 것이다. 윈도우즈는 가상 머신들 (VMs)을 통합하고 감독하기 위한 일만을 하는 프로그램이 필요하게 되었다. 그것이 VIRTUAL MACHINE MANAGER이다. 

=== VIRTUAL MACHINE MANAGER ===

VMM은 32비트 보호 모드 프로그램이다. 가상 머신을 지원하는 프레임 워크를 세우고 유지하는 일을 주로 한다. VMs를 생성하고 동작시키고 종료시키는 일을 하는 것이다. VMM은 시스템 폴더안에 VMM32.VXD 안에 저장되어있는 많은 시스템 VxD들 중에 하나이다. 윈도우즈 95의 부팅 순서를 살펴보자. 

 1. io.sys 가 메모리에 저장된다. 
 2. config.sys 와 autoexec.bat가 처리된다. 
 3. win.com이 호출된다. 
 4. win.com 이 실제로는 단순한 도스 exe 파일인 VMM32.VXD를 실행시킨다. 
 5. VMM32.VXD는 XMS드라이버를 사용해서 VMM을 확장 메모리에 올려놓는다. 
 6. VMM은 자신과 다른 디폴트 가상 장치 드라이버들을 초기화한다. 
 7. VMM은 보호 모드로 머신을 바꾸고 시스템 가상 머신을 생성한다. 
 8. 마지막에 올려진 Virtual Shell Device는 시스템 VM 안에서 krnl386.exe를 실행시킴으로서 윈도우즈를 시작시킨다. 
 9. krnl386.exe 은 다른 모든 파일들을 올려놓으면서 윈도우의 95의 쉘을 완성시킨다. 

보다시피 VMM은 메모리에 올려지는 첫 번째 VxD이다. 시스템 가상 머신을 생성하고 다른 VxD들을 초기화한다. 또한 이 VxD들에게 많은 서비스를 지원한다. 

VMM과 VxD들의 실행 모드는 저 진짜 프로그램들과 다르다. 그것들은 대부분의 시간동안 잠을 잔다. 응용 프로그램들이 시스템에서 동작할동안 이 VxD들은 동작하지 않는다.그것들은 인터럽트/폴트/이번트 들이 일어나 그들이 주의를 기울여야 할 때만 깨어난다. 

VMM은 재진입이 되지 않는다. 이것은 VxD들이 VMM의 서비스에 접근하기 위해서는 서로 동기를 맞추어야 한다는 것을 의미한다. 하드웨어 인터럽트가 실행되고 있을 때와 같이 VMM 서비스를 호출하는 것이 안전하지 못한 경우가 몇가지 있다. VMM은 재진입을 허용하지 않는다. VxD를 만드는 사람들은 매우 조심해서 일을 해야 한다. 당신의 잘못된 코드에 대해 신경써줄 것이 전혀 없다는 것을 기억해라. 당신은 ring 0에서 완벽히 스스로 책임 저야 하는 것이다. 

=== Virtual Device Driver ===

가상 장치 드라이버는 VxD로 줄여쓴다. x는 가상 키보드 드라이버, 가상 마우스 드라이버 등과 같이 장치 이름을 쓰는 곳이다. VxD들은 성공적인 하드웨어 가상화를 위한 열쇠가 된다. 도스 프로그램들은 그것들이 시스템의 모든 것을 소유하고 있다고 생각한다는 것을 기억하자. 그것들이 가상 머신에서 동작할 때 윈도우즈가 진짜 장치에 대한 대역으로 지원하는 것이다. VxD는 대역이다. VxD는 보통 몇가지 하드웨어 장치를 가상화시킨다. 그래서 예를 들면 도스 프로그램이 키보드와 작동하고 있다고 생각할 때 실제로는 가상 키보드 장치와 동작하고 있는 것이 된다. VxD는 보통 진짜 하드웨어 장치를 조정하고 VM들 사이에서 장치를 공유하도록 관리한다. 

그러나 VxD가 꼭 하드웨어 장치와 대응되어야 한다는 규칙은 없다. VxD가 가상 하드웨어 장치를 위해 만들어진 것은 사실이지만 우리는 VxD를 ring 0 DLL과 같이 다룰 수가 있다. 예를 들어오직 ring 0에서만 동작해야 하는 기능들을 원한다면 VxD를 만들어서 그 일을 하게 하면 된다. 따지고 보면 VxD를 하드웨어 장치에 대한 가상화 보다는 당신의 프로그램의 확장이라고 볼수도 있다. VxD를 만들어보기 전에 첫 번째로 그것들에 대한 몇가지를 짚어 주겠다. 

 * VxD는 윈도우즈 9x에서만 동작한다. 윈도우즈 NT에서는 동작 시킬수 없다. 따라서 VxD를 이용해 만들어진 프로그램은 윈도우즈 NT 기반으로 이식될수 없다. 
 * VxD는 시스템에서 가장 힘이 센 부분이다. 따라서 시스템에 무슨 짓이든지 할 수 있고 극도로 위험할수 있다. 잘못된 VxD는 시스템을 충돌시킬 수 있다. 잘못된 VxD에 대한 보호는 전혀 없다. 
 * 보통은 VxD를 의지하지 않고도 당신이 원하는 목적을 이룰 수 있는 많은 방법이 있다. VxD로 해결하기 전에 생각하고 또 생각하자. ring 3에서 해결할 수 있는 다른 방법이 있다면 그걸 이용하자. 

윈도우즈 95에서는 두가지 방식의 VxD가 있다. 

 * 정적 VxD 
 * 동적 VxD 

정적 VxD는 시스템이 켜질때부터 실행되서 꺼질때까지 저장되어 남아있는 것이다. 윈도우즈 3.x 시절부터 사용된 방식이다. 동적 VxD는 윈도우즈 9x에서만 사용할 수 있다. 동적 VxD는 필요할때마다 로드하고 해제할 수 있다. 대부분 Configuration Manager 와 Input Output Supervisor 에 의해 로드된 플러그 앤 플레이 장치를 제어한다. 또한 당신의 win32 응용프로그램에서도 동적 VxD를 사용할 수 있다. 

=== Communication between VxDs ===

VMM을 포함해서 VxD들은 세가지 메카니즘을 통해 서로 통신할수 있다. 

 * Control Message 
 * Service APIs 
 * Callbacks 

Control Message: 어떤 흥미로운 이번트가 발생했을 때 VMM은 시스템에 로드된 모든 VxD에 시스템 콘트롤 메시지를 보낸다. 이럴 때 콘트롤 메시지는 ring 3 윈도우즈 어플리케이션에서의 윈도우즈 메시지와 비슷하다. 모든 VxD는 Device Control Procedure 라고 불리는 콘트롤 메시지를 받고 처리하는 함수를 가지고 있다. 대략 50개 정도의 시스템 콘트롤 메시지가 있다. 콘트롤 메시지가 많지 않은 이유는 시스템에 자주 많은 VxD가 로드되어 있고 각각이 모든 콘트롤 메시지의 조각을 받을 것인데 만약 너무 많은 콘트롤 메시지가 있을 경우 시스템이 멈추게 될 것이기 때문이다. 그래서 VM이 생성되거나 파괴되는 그런 경우같이 VM에 관해 매우 중요한 메시지만이 있는 것을 알 것이다. 시스템 콘트롤 메시지에 덧붙여 VxD는 고유한 보통의 콘트롤 메시지를 정의할수 있고 그것을 이해하는 다른 VxD와 통신할 수 있다. (역자: 몇몇의 VxD들이 서로 통신할 때 새로 어떤 메시지를 만들어 자기들 끼리만 이해하면서 쓸 수 있다는 뜻인 것 같습니다.) 

Service APIs : VMM과 VxD는 일반적으로 다른 VxD가 호출할 수 있는 공용 함수 세트를 만들 수 있다. 그 함수들은 VxD 서비스라고 불린다. 이들 VxD 서비스들을 호출하는 메카니즘은 저 ring 3 어플리케이션과 상당히 다른 것이다. VxD 서비스를 만든 모든 VxD들은 반드시 고유한 ID번호를 가져야 한다. 당신은 Microsoft로부터 그러한 ID를 얻을 수 있다. 그 ID는 VxD를 독자적으로 정의하는 16비트 번호이다. 

UNDEFINED_DEVICE_ID EQU 00000H 

VMM_DEVICE_ID EQU 00001H 

DEBUG_DEVICE_ID EQU 00002H 

VPICD_DEVICE_ID EQU 00003H 

VDMAD_DEVICE_ID EQU 00004H 

VTD_DEVICE_ID EQU 00005H 

VMM의 ID는 1, VPICD의 ID는 3 등인 것을 알수 있다. VMM은 이 고유한 ID를 가지고 요청된 VxD 서비스를 제공하는 VxD를 찾아낸다. 또한 서비스 브랜체 테이블의 인덱스를 가지고 호출하고자 하는 서비스를 선택해야 한다. VxD가 VxD서비스를 제공할 때 테이블에 서비스의 주소를 저장한다. VMM은 서비스 테이블에서 요청된 서비스의 주소를 찾기 위해서 제공된 인덱스를 사용한다. 예를 들어 최초의 서비스인 GetVersion을 로츌하기 위해서는 0번(인덱스는 0부터 시작한다)을 지정해야 한다. VxD 서비스를 호출하는 원래 메카니즘은 INT 20H를 포함하고 있다. 당신의 코드는 장치 ID와 서비스 인덱스로 이루어진 더블 워드 값을 INT 20H 다음에 표시해야 한다. 코드는 다음과 같다. 

{{{
INT 20H 
DD 000D0001H 
}}}

INT 20H 다음에 나온 더블 워드 값의 상위 워드는 장치 ID를 나타낸다. 하위 워드는 0부터 시작되는 서비스 테이블의 인덱스이다. 

INT 20H를 만나면 VMM은 제어를 시작하고 인터럽트 명령어 바로 다음에 나오는 더블 워드를 확인한다. 그후 장치 ID로 해당 VxD를 찾고 서비스 인덱스를 가지고 그 VxD안에 있는 요청된 서비스의 주소를 알아낸다. 

이 연산에 시간을 잡아먹는 다는 것을 알 수 있을 것이다. VMM은 VxD를 찾고 요청된 서비스의 주소를 알아내는 데에 시간을 보내야 한다. 그래서 VMM은 약간의 속임수를 쓴다. 처음의 INT 20H 연산이 성공하면 VMM은 그 연결를 잡아 놓는다. 연결을 잡아 놓는다는 것은 INT 20과 그 뒤의 더블 워드를 서비스의 직접 호출로 바꾼다는 것을 의미한다. 따라서 위의 코드 조각은 다음으로 변환된다. 

CALL DWORD PTR [VXD_SERVICE_ADDRESS] 

INT 20과 더블 워드는 6바이트가 되고 CALL DWORD PTR 연산도 같으므로 이 트릭은 성공할 수 있다. 그래서 다음의 호출들은 빠르고 효율적일 수 있다. 이 방은 장단점이 있다. 장점으로는 로드할 때에 VxD의 모든 서비스 함수들을 고정할 필요가 없기 때문에 VMM과 VxD 로더의 일을 줄일 수 있다는 것이다. 절대 실행되지 않는 호출들은 수정되지 않을 것이다. 좋지 않은 면으로는 한번 서비스가 링크된 정적 VxD는 해제되기가 불가능하다는 것이다. VMM은 호출들을 VxD의 서비스의 실제 주소로 고정시키기 때문에 이 서비스들을 제공하는 VxD들이 메모리에서 해제되면 이들의 서비스에 관련된 다른 VxD들은 잘못된 메모리 주소를 호출할 것이고 시스템 충돌이 일어날 것이기 때문이다. 링크들을 풀어주는 메카니즘은 없다. 결론은 VxD 서비스를 제공하기에는 동적 VxD가 적당하지 않다는 것이다. 

CALLBACKS: CALLBACKS나 CALLBACK 함수들은 다른 VxD들에 의해 호출되기 위해 VxD에 존재하는 함수들이다. CALLBACKS는 서비스들 처럼 공용은 아니다. 그것들은 특정한 상황에서 VxD가 다른 VxD에게 자신의 주소를 전해주는 비공개 함수이다. 예를 들어 한 VxD가 하드웨어 인터럽트를 서비스 할 때 VMM은 재진입이 되지 않기 때문에 페이지 폴트를 발생할 수 있는 어떠한 VxD의 서비스들도 그 VxD는 사용할 수 없다(그래서 VMM에 재진입해야 한다). (역자: 전혀 이해가 되지 않는 문장입니다. For example, when a VxD is servicing a hardware interrupt , since VMM is not reentrant, the VxD cannot use any VxD services that may cause page faults (thus re-enter VMM). ) VxD가 자신만의 함수중 하나의 주소를 VMM에게 전해주면 VMM은 그 함수를 VMM이 페이지 폴트를 처리할 수 있을 때 호출할 수 있다. (역자: 그럼 재진입이 안된다는 것이 아니라 함수 주소를 메시지로 보내주면 재진입이 가능하다는 뜻이 되는 것 같습니다.) VxD은 자신의 콜백 함수가 호출 되었을 때 자신의 일를 처리할 수 있다. 콜백 개념은 VxD에만 사용되는 것이 아니다. 많은 윈도우즈 API들이 마찬가지 개념을 사용하고 있다. 가장 좋은 예는 윈도우 프로시저가 될 것 같다. 당신은 윈도우 프로시저의 주소를 WNDCLASS나 WNDCLASSEX 구조체로 지정하고 RegisterClass나 RegisterClassEx 호출로 윈도우즈에 전달한 것이다. 윈도우즈는 그 윈도우를 위한 메시지가 있을때에 당신의 윈도우 프로시저를 호출 할 것이다. 다른 예는 윈도우 Hook 프로시저이다. 당신의 어플리케이션은 윈도우즈에게 Hook 프로시저의 주소를 주어서 어플리케이션에 해당하는 이벤트가 일어났을 때 윈도우즈가 호출할 수 있게 한다. 

위의 세가지 방법은 VxD들이 서로 통신하기 위한 것들이다. V86과 보호모드, Win32 어플리케이션을 위한 인터페이스들도 있다. 다음 문서에서 Win32 어플리케이션을 위한 VxD 인터페이스를 다루겠다. 

== Virtual Machine Manager ==
가상 머신 관리자 (VMM) 은 윈도우즈 95 뒤에 있는 진짜 운영체제이다. 가상 머신을 관리하기 위한 프레임 워크를 세우고 유지하는 일을 한다. 또한 다른 VxD들에게 많은 중요한 서비스들을 제공한다. 다음은 세가지 중요한 서비스들이다. 

 * Memory management 
 * Interrupt handling 
 * Thread scheduling 

=== Memory Management  ===

VMM은 시스템 VM을 위한 32비트 가상 주소 공간을 생성하기 위해 인텔 80386 이후 프로세서에서 지원하는 페이징 기능을 이용한다. 주소 공간은 네 개의 다른 영역으로 나누어진다. 

 * V86 region 주소 0H부터 10FFEFH까지의 영역이다. 현재 실행중인 가상 머신에 속해있는 지역이다. 
 * Private application region 4MB부터 2GB까지의 영역이다. WIN32 어플리케이션이 동작하는 영역이다. 각 win32 프로세스는 각기 고유한 2GB(에서 4MB뺀) 영역을 가진다. 
 * Shared application region 2GB부터 3GB의 영역이다. 이 영역은 시스템 VM의 모든 어플리케이션에게 공유된다. 이 영역은 시스템 DLLs(user32, kernel32, gdi32)가 있는 영역이다. 모든 Win16 어플 또한 여기 존재하는데 그것들이 ill-behaved하기 때문이다 : they are used to reading/writing from/to other win16 apps in memory. (역자: 해석 불가... 실력이 딸려서리...) 이 지역안에 Win16 어플들이 다른 모든 Win16 어플들을 찾아 볼수 있다. Memory mapped 파일들은 DPMI 콜들에 메모리가 할당되는 것처럼 여기에 저장된다. 
 * Shared system region 3GB부터 4GB이다. VMM과 VxD들이 사는 곳이다. 

VMM은 VxD에게 세가지 타입의 메모리 서비스를 제공한다. 

 * Page-based memory services 이 서비스 형태는 4KB의 페이지로 메모리를 할당하고 관리한다. 가능한 최하위 레벨의 메모리 서비스이다. 다른 메모리 서비스들은 그 바탕에 이 서비스를 사용하고 있다. 
 * Heap memory services 더 작은 메모리 블록을 관리한다. page-based 방식의 꼭대기에 세워진 최고 레벨의 메모리 관리이다. 
 * List services 링크드 리스트로 제공되는 고정된 크기의 메모리 블록을 관리한다. 

=== Interrupt Handling ===

보호모드에서 인터럽트들은 인터럽트 디스크립터 테이블 (IDT)를 가리키고 있다. VMM은 VxD들의 도움을 받아 VM들의 IDT들을 감시한다. 보통 VMM은 IDT들의 거의 모든 항목들을 다룬다. 인터럽트된 프로그램의 상태를 스택에 저장하고 다양한 VxD들에 의해서 제공되는 실제 처리를 위한 두 번째 단계의 인터럽트 핸들러들로 바뀔 첫 번째 단계의 인터럽트 핸들러들을 제공한다. 두 번째 단계의 핸들러들이 일을 끝내면 인터럽트된 프로그램의 상태를 되돌려놀 복구 루틴의 제어로 넘어가고 이전에 인터럽된 지점에서 다시 실행되게 된다. 

위의 묘사는 너무 단순한 것이다. 인터럽트된 VM의 할당 시간이 다 지났다면 복귀는 즉시 이루어지지 않을 것이다. VxD들은 Set_PM_Int 나 Hook_V86_Int_Chain같은 VMM 서비스를 통해 인터럽트 핸들러를 설치할 수 있다. VxD들이 직접 IDT의 항목들을 설정하면 않된다(하지만 뭘 해야 할지 정확히 않다고 생각하면 그렇게 해도 된다). 

=== Thread Scheduling ===

VMM은 쓰레드들과 VM들간에 선점형 멀티 태스킹을 제공하기 위해서 두가지 스케줄러 요소를 사용한다. 

 * primary scheduler 
 * time-slice or secondary scheduler 

primary scheduler의 임무는 최고 실행 권한을 가진 쓰레드를 고르는 것이다. VMM이 인터럽트(TIME INTERRUPT같은)를 서비스하는 동안 선택이 이루어진다. VMM이 인터럽트의 서비스를 마칠 때 어떤 쓰레드 혹은 VM에게 제어권을 줄지 결정이 난다. Primary scheduler는 모 아니면 도의 방식으로 실행된다. 한 쓰레드는 실행되거나 혹은 안되는 것이다. 오직 하나의 쓰레드가 선택되어 진다. VMM과 다른 VxD들은 VMM 서비스를 통해 쓰레드의 실행 권한을 높이거나 조절할 수 있다. 예를 들어 하드웨어 인터럽트가 발생하면 VMM은 인터럽트 핸들어의 실행 권한을 높여서 가장 짧은 시간내에 실행된 기회를 높여주게 된다. 

Secondary scheduler uses the services of the primary scheduler to allocate CPU time among threads that share the highest execution scheduler priority by giving the execution priority by giving each thread a time slice. 한 쓰레드에게 할당된 시간이 다 지나면 secondary scheduler는 다음 쓰레드의 실행 권한을 끌어놀려서 primary scheduler가 선택해서 실행될 수 있게 한다. 

== VIRTUAL DEVICE DRIVER SKELETON ==

이제 VMM과 VxD에 대해 알았으니 VxD를 코딩하는 걸 알아보자. WINDOWS 95/98 DEVICE DRIVER DEVELOPMENT KIT가 필요하다. 꼭 준비해야 한다. WINDOWS 95 DDK는 MSDN 구독자만 얻을수 있다. 하지만 WINDOWS 98 DDK는 마이크로소프트에서 무료로 제공해준다. WDM으로 나아가려고 했다해도 WINDOWS 98 DDK로 VxD을 만들 수 있다. HTTP://WWW.MICROSOFT.COM/HWDEV/DDK/INSTALL98DDK.HTM?에서 WINDOWS 98 DDK를 다운 받을 수 있다. 

30MB정도 되는 모든 패키지를 다 다운 받거나 관심있는 몇가지 파트만 선택해서 다운 받을 수도 있다. 전체 패키지를 다운받지 않으려고 한다면 ORTHER.EXE 안에 포함되어 있는 WINDOWS 95 DDK 문서를 잊지말고 다운 받도록 한다. 

WINDOWS 98 DDK는 MASM 6.11d 버전을 가지고 있다. 최종 버전으로 업그레이드 해야 한다. 내 메인 페이지를 확인해서 최종 버전에 대해 알아볼수 있다. 

WINDWOS 9x DDK는 MASM32 패키지에 들어있지 않은 몇가지 중요한 파일을 가지고 있다. 이 문서에서 그 예를 다운받을 수 있다. 

=== LE FILE FORMAT ===

VxD는 linear executable (LE) 파일 포맷을 사용한다. OS/2 2.0 버전을 위해 만들어진 파일 포맷이다. VxD에서 필요한 16과 32비트 코드 모두 사용될수 있다. VxD가 WINDOWS 3.x 시대부터 사용陖다는 것을 기억하자. 그때는 윈도우즈가 도스에서 부팅되었으므로 보호모드로 전환하기 전에 리얼 모드에서 몇가지 초기화를 해야 했었다. 16비트 리얼 모드 코드는 32비트 보호모드 코드와 같은 실행 파일에 있어야만 했다. 그래서 LE 파일 포맷이 선택되었다. 다행히 윈도우즈 NT는 리얼 모드를 다룰 필요가 없으므로 LE 파일 포맷을 사용하지 않는다. 대신 PE 파일 포맷을 사용한다. 

LE 파일의 코드와 데이터는 다른 런타임 속성들을 세그먼트에 저장한다. 밑에 가능한 세그먼트 클래스들이 있다. 

 * LCODE 코드와 데이터가 있는 잠겨 있는 페이지. 이 세그먼트는 메모리에 잠겨져 있다. 다시 말해서 디스크에 페이지될 수 없고 시스템 메모리를 낭비하지 않기 위해 지혜롭게 사용해야 할 세그먼트이다. 이 세그먼트의 코드와 데이터들은 항상 메모리에 위치한다. 특히 하드웨어 인터럽트 핸들러가 있다. 
 * PCODE 페이지 되는 코드. VMM에 의해 페이지 될 수 있는 세그먼트이다. 이 세그먼트의 코드들은 항상 메모리에 있을 필요가 없다. VMM은 물리 메모리가 모자를 때 이 세그먼트를 디스크로 페이지 할 수 있다. 
 * PDATA 페이지 되는 데이터. 
 * ICODE 초기화만을 위한 코드. 이 세그먼트의 코드들은 VxD의 초기화에만 사용횐다. 초기화 후에는 물리 메모리를 확보하기 위해 VMM이 지우게 된다. 
 * DBOCODE 디버그만을 위한 코드와 데이터. 디버거에서 VxD를 실행했을 때 이 세그먼트의 코드와 데이터가 사용된다. 예를 들면 Debug_Query 콘트롤 메시지의 핸들러가 여기 있다. 
 * SCODE 정적 코드와 데이터. VxD가 해제되더라도 항상 메모리에 존재한다. 윈도우즈 세션에서 자주 로드되고 해제되며 최근 설정과 상태를 저장해야 하는 VxD를 위해 항상 사용된다. 
 * RCODE 리억 모드 초기화를 위한 코드와 데이터. 리얼 모드 초기화를 위한 16비트 데이터와 코드를 가지고 있는 세그먼트이다. 
 * 16ICODE USE 16 보호모드 초기화 데이터. VxD가 보호모드에서 V86모드로 복사할 코드를 가지고 있는 16비트 세그먼트이다. 예를 들어 VM으로 V86을 복사하려 한다면 이 세그먼트로 복사되야 한다. 다른 세그먼트에 넣으면 어셈블러는 잘못된 코드를 생성할 것이다. 또 16비트 대신 32비트 코드를 만들 것이다. 
 * MCODE 잠긴 메시지 문자열. VMM 메시지 매크로와 컴파일된 메시지 문자열을 가지고 있다. 드라이버의 국제 버전을 만들 수 있게 해준다. 

VxD가 이 모든 세그먼트를 가져야 한다는 것은 아니다. VxD에서 사용할 세그먼트를 고르면 된다. 예를 들어 리얼 모드 초기화가 필요 없다면 RCODE 세그먼트를 쓸 필요가 없다. 

대부분 LCODE, PCODE, PDATA를 사용한다. 코드와 데이터를 위해 적당한 세그먼트를 고르는 것은 VxD 만드는 사람의 판단이다. 가능하면 PCODE와 PDATA를 사용해서 필요할때마다 VMM이 세그먼트를 메모리에서 세그먼트를 페이지 할 수 있도록 해야 한다. 하드웨어 인터럽트 핸들러가 호출하는 하드웨어 인터럽트 핸들러와 서비스들을 저장하기 위해서는 LCODE를 사용해야 한다. 

직접 이 세그먼트들을 사용하지는 않는다. 이 분류들을 가지고 세그먼트를 정의해야 한다. 이 세그먼트 정의들은 모듈 정의 파일 (.def)에 저장되어 있다.VxD의 모든 모듈 정의 파일은 다음과 같다. 

{{{
VXD FIRSTVXD 

SEGMENTS 

_LPTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LDATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_DATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

CONST CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TLS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_BSS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LMGTABLE CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_LMSGDATA CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_IMSGTABLE CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_IMSGDATA CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_ITEXT CLASS 'ICODE' DISCARDABLE 

_IDATA CLASS 'ICODE' DISCARDABLE 

_PTEXT CLASS 'PCODE' NONDISCARDABLE 

_PMSGTABLE CLASS 'MCODE' NONDISCARDABLE IOPL 

_PMSGDATA CLASS 'MCODE' NONDISCARDABLE IOPL 

_PDATA CLASS 'PDATA' NONDISCARDABLE SHARED 

_STEXT CLASS 'SCODE' RESIDENT 

_SDATA CLASS 'SCODE' RESIDENT 

_DBOSTART CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBOCODE CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBODATA CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_16ICODE CLASS '16ICODE' PRELOAD DISCARDABLE 

_RCODE CLASS 'RCODE' 

EXPORTS 

FIRSTVXD_DDB @1 


SEGMENTS 

_LPTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LDATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_DATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

CONST CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TLS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_BSS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LMGTABLE CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_LMSGDATA CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_IMSGTABLE CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_IMSGDATA CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_ITEXT CLASS 'ICODE' DISCARDABLE 

_IDATA CLASS 'ICODE' DISCARDABLE 

_PTEXT CLASS 'PCODE' NONDISCARDABLE 

_PMSGTABLE CLASS 'MCODE' NONDISCARDABLE IOPL 

_PMSGDATA CLASS 'MCODE' NONDISCARDABLE IOPL 

_PDATA CLASS 'PDATA' NONDISCARDABLE SHARED 

_STEXT CLASS 'SCODE' RESIDENT 

_SDATA CLASS 'SCODE' RESIDENT 

_DBOSTART CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBOCODE CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBODATA CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_16ICODE CLASS '16ICODE' PRELOAD DISCARDABLE 

_RCODE CLASS 'RCODE' 

EXPORTS 

FIRSTVXD_DDB @1 

}}}

첫 번째 문장은 VxD 이름을 정의하는 것이다. VxD의 이름은 모두 대문자이어야 한다. 소문자로 시험해봤는데 VxD가 메모리로 로드될 때 뭔가 수행에 장애가 있었다. 

다음은 세그먼트 정의이다. 정의는 세가지 파트로 이루어진다. 세그먼트의 이름, 세그먼트 클래스, 세그먼트의 실행 속성이다. 같은 클래스에 여러 가지 세그먼트들이 있는 것을 볼수 있다. 예를 들면 _LPTEXT, _LTEXT, _LDATA는 정확히 같은 속성을 가진 LCODE 세그먼트 클래스이다. 이 세그먼트들은 코딩을 이해하기 쉽게 만들기 위해 정의된다. 예를 들면, LCODE는 코드와 데이터 둘다 가질 수 있다. _LDATA 세그먼트에 데이터를 _TEXT 세그먼트에 코드를 저장한다면 프로그래머가 더 편리할 것이다. 나중에 최종 실행 파일에서는 두 세그먼트가 단 하나로 합쳐질 것이다. 

한 VxD는 단 하나의 device descriptor block (DDB)를 내놓는다. DDB는 VMM이 한 VxD에 대해서 알아야 하는 모든 것을 담고 있는 구조체이다. 반드시 모듈 정의 파일안에 DDB를 내놓아야 한다. 

대부분 새로운 VxD 프로젝트에서 위의 .DEF 파일을 사용할 수 있다. .DEF 파일의 처음과 끝의 VxD의 이름만 바꾸면 된다. 어셈블리 VxD 프로젝트에서 이 세그먼트 정의들은 지나치게 많다. C VxD 프로젝트를 위해 사용되는 것들이지만 어셈블리 프로젝트에서도 괸찬다. 주의 메시지가 많이 발생할 수 있지만 어셈블은 할 수 있다. 프로젝트에서 사용되지 않는 세그먼트 정의들을 지우면 주의 메시지들을 피할 수 있다. 

VMM.INC는 소스 파일에서 세그먼트를 정의하기 위한 많은 매크로들을 가지고 있다. 

{{{
_LTEXT VxD_LOCKED_CODE_SEG 

_PTEXT VxD_PAGEABLE_CODE_SEG 

_DBOCODE VxD_DEBUG_ONLY_CODE_SEG 

_ITEXT VxD_INIT_CODE_SEG 

_LDATA VxD_LOCKED_DATA_SEG 

_IDATA VxD_IDATA_SEG 

_PDATA VxD_PAGEABLE_DATA_SEG 

_STEXT VxD_STATIC_CODE_SEG 

_SDATA VxD_STATIC_DATA_SEG 

_DBODATA VxD_DEBUG_ONLY_DATA_SEG 

_16ICODE VxD_16BIT_INIT_SEG 

_RCODE VxD_REAL_INIT_SEG 
}}}

각 매크로들은 매크로의 끝에 사용되는 짝이 있다. 소스에서 _LTEXT 세그먼트를 정의하려고 하면 다음과 같이 한다. 

{{{
VxD_LOCKED_CODE_SEG 

< put your code here > 

VxD_LOCKED_CODE_ENDS 

VxD Skeleton 
}}}

LE 파일에서 세그먼트에 대해 알았으면 소스 파일로 가보자. VxD 프로그래밍에서 한가지 볼수 있는 것은 매크로를 매우 많이 사용한다는 것이다. VxD 프로그래밍 어디에서든지 매크로를 볼 수 있다. It takes some getting used to. (역자: 관용어로 된 문장이라 뭐라 번역하기가 애매합니다. 매크로를 사용할 만한 당연한 이유가 있다는 의미인 것 같습니다.) 매크로들은 프로그래머에게 너무 자세하고 어려운 부분들을 숨겨주고 몇가지 방법들로 소스 코드를 이식 가능하게 만들어 준다. 궁금하면 vmm.inc 같은 파일에 정의돈 다양한 매크로들의 정의를 읽어볼 수 있다. 

여기 VxD의 기본 소스 코드가 있다. 

{{{
.386p 

include vmm.inc 


DECLARE_VIRTUAL_DEVICE FIRSTVXD, 1,0,FIRSTVXD_Control, 

UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER 


Begin_control_dispatch FIRSTVXD 

End_control_dispatch FIRSTVXD 


end 
}}}

처음 스쳐보면 어셈블리 소스 코드같아 보이지는 않을 것이다. 매크로들 때문이다. 소스 코드를 분석하면 금방 이해할 것이다. 

.386p 

어셈블러에게 80386의 명령어들과 특권 명령어를 사용하기 원한다는 것을 말한다. .486p나 .586p도 사용할 수 있다. 

include vmm.inc 

vmm.inc는 소스 파일에서 사용하는 매크로의 정의 코드들을 모두 가지고 있기 때문에 반드시 써야 한다. 필요하다면 다른 파일들도 포함할 수 있다. 

DECLARE_VIRTUAL_DEVICE FIRSTVXD,1,0,FIRSTVXD_Control, 

UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER 

앞서 말했듯이 VMM는 VxD의 DEVICE DESCRIPTOR BLOCK (DDB)에서 VxD에 관해 알아야 하는 것들을 알아낸다. DEVICE DESCRIPTOR BLOCK는 VxD의 이름이나 장치 ID, VxD 서비스의 진입점등과 같이 VxD에 관한 필수적인 정보들을 가지고 있는 구조체이다. vmm.inc에서 이 구조체를 볼 수 있다. VxD_Desc_Block 라고 정의되어 있다. .DEF 파일 안에서 이 구조체를 내놓을 수 있다. 22가지의 항목들이 있지만 보통 몇가지만 채울 필요가 있을 것이다. 그래서 vmm.inc는 구조체를 초기화하고 채울 매크로를 가지고 있다. 그 매크로는 DECLARE_VIRTUAL_DEVICE 이다. 다음과 같은 형식이다. 

Declare_Virtual_device Name, MajorVer, MinorVer, CtrlProc, DeviceID, InitOrder, V86Proc, PMProc, RefData 

지켜봐야 할 것은 VxD 소스 코드는 대소문자를 구별한다는 것이다. 대문자나 소문자 혹은 둘다를 섞어서 사용할 수 있다. 각 인자들을 살펴보자. 

 * Name VxD의 이름이다. 최고 8글자이다. 반드시 대문자여야 한다. 시스템의 VxD들 중에서 유일해야 한다. 또 매크로는 장치 이름에 _DDB를 붙여서 DDB의 이름을 만들어 쓴다. 그래서 VxD의 이름을 FIRSTVXD라고 쓰면 이 매크로는 DDB를 FIRSTVXD_DDS라고 이름을 정한다. .DEF 파일에도 DDB를 내놓아야 한다는 것을 기억하자. 소스 파일과 .DEF 파일의 라벨이 같아야 한다. 
 * MajorVer와 MinorVer VxD의 버전이다. 
 * CtrlProc VxD의 device control procedure 의 이름이다. 장치 제어 프로시저는 VxD의 콘트롤 메시지들을 받고 처리하는 함수이다. 윈도우 프로시저와 같다고 생각하면 된다. 장치 제어 프로시저를 만들기 위해 Begin_Control_Dispatch 매크로를 사용하기 때문에 VxDName_Control의 형태로 되는 표준 이름을 사용하게 된다. Begin_Control_Dispatch 매크로는 보내지는 이름에 _Control을 붙이므로 (그리고 보통 VxD의 이름을 매크로로 보낸다.) CtrlProc 인자에 VxD의 이름에 _Control을 붙인 것을 지정해야 한다. 
 * DeviceID VxD를 가리키는 유일한 16비트 값이다. 아래의 상황에서 ID가 필요하다. 
  * VxD가 다른 VxD에게 서비스를 내놓을 때. INT 20H 인터페이스는 VxD를 찾고 지정하는데 장치 ID를 사용하므로 VxD는 반드시 고유한 지정값을 가져야 한다. 
  * VxD는 초기화 하는 동안 INT 2FH의 함수 1607H로 리얼 모드 어플리케이션들에게 자신의 존재를 알려야 한다. 
  * 어떤 리얼 모드 소프트웨어 (TSR) 은 VxD를 로드하기 위해 INT 2FH의 함수 1605H를 사용한다. 

고유 장치 ID가 필요없는 VxD는 UNDEFINED_DEVICE_ID로 지정하면 된다. 고유한 ID가 필요하면 마이크로소프트에 요청할 수 있다. 

 * IinitOrder 초기화 순서 짧게는 로드 순서. VMM은 VxD들을 지정된 순서로 로드한다. 각 VxD는 로드 순서 번호를 가지고 있다. 예를 들면 

VMM_INIT_ORDER EQU 000000000H 

DEBUG_INIT_ORDER EQU 000000000H 

DEBUGCMD_INIT_ORDER EQU 000000000H 

PERF_INIT_ORDER EQU 000900000H 

APM_INIT_ORDER EQU 001000000H 

VMM, DEBUG, DEBUFCMD가 처음 올라오는 VxD임을 알 수 있고 그 다음으로 PERF, APM이다. 작은 값이 초기화 번호가 먼저 올라오게 된다. VxD가 초기화되는 동안 다른 VxD의 서비스가 필요하면 다른 VxD들이 먼저 올라온 다음에 호출 할 수 있도록 순서 값을 보다 크게 정해서 다른 VxD들이 먼저 메모리에 올라오게 한다. 초기화 순서가 상관이 없으면 UNDEFINED_INIT_ORDER 로 인자를 정해준다. 

 * V86Proc and PMProc VxD는 V86이나 보호 모드 프로그램들이 사용할 API를 내놓을 수 있다. V86Proc와 PMProc는 이 API들의 주소를 정하게된다. VxD는 주로 도스나 보호 모드 어플리케이션을 실행하는 시스템 VM보다는 다른 VM들을 관리한다는 것을 기억하자. 그래서 도스와 보호모드 프로그램을 위한 API를 제공하는 VxD가 있는 이유이다. 이 API를 제공하지 않는다면 생략해도 된다. 
 * RefData Input Output Supervisor (IOS) 가 참조하기 위한 데이터. IOS를 위한 layer block driver를 만들 때에만 여기를 사용한다. 그 외에는 생략한다. 

다음으로 Begin_Control_Dispatch를 써보자 

Begin_control_dispatch FIRSTVXD 

End_control_dispatch FIRSTVXD 

이 매크로와 그 짝은 VMM이 VxD에 대한 콘트롤 메시지가 생겼을 때 호출하는 함수인 장치 제어 프로시저를 정의한다. 장치 제어 프로시저의 이름의 앞에 반은 직접 지정해야 한다. 여기서는 FIRSTVXD로 사용했다. 매크로는 지정해진 이름에 _Control을 붙인다. 이 이름은 Declare_virtual_device 매크로에서 CtrlProc의 인자로 지정한 이름과 같아야 한다. 장치 제어 프로시저는 언제나 잠겨있는 세그먼트 (VxD_LOCKED_CODE_SEG)에 저장되어야 한다. 위의 장치 제어 프로시저는 아무 일도 하지 않는다. VxD가 다루어야 할 콘트롤 메시지와 그것을 다룰 함수를 지정해야 한다(역자: 메시지와 그걸 처리할 함수를 묶어줘야 한다는 의미 같습니다). 이를 위해 Control_Dispatch 매크로를 사용할 수 있다. 

Control_Dispatch message, function 

예를 들어 VxD가 Device_Init 메시지를 처리한다면 장치 제어 프로시저는 다음과 같게 된다. 

{{{
Begin_Control_Dispatch FIRSTVXD 

Control_Dispatch Device_Init, OnDeviceInit 

End_Control_Dispatch FIRSTVXD 
}}}

OnDeviceInit은 Device_Init 메시지를 다룰 함수의 이름이다. 원하는 대로 이름을 정해주면 된다. 

end 지시자로 VxD 소스 코드를 끝내주면 된다. 

요약하자면 최소한 VxD는 장치 제어 블록과 장치 제어 프로시저를 가져야 한다는 것이다. 장치 제어 블록은 Declare_Virtual_Device 매크로로 지정하고 장치 제어 프로시저는 Begin_Control_Dispatch 매크로로 지정할 수 있다. 장치 제어 블록을 .DEF 파일의 EXPORTS 지시자 밑에 이름을 써주어야 한다. 


=== Assembling the VxD ===

어셈블은 보통 win32 어플리케이션을 어셈블링 하는 것과 같이 사용한다. 소스 파일은 ml.exe로 호출하고 오브젝트 파일은 link.exe로 링크한다. 다른 점은 명령행 스위치들을 사용하는 것이다. 

ml -coff -c -Cx -DMASM6 -DBLD_COFF -DIS_32 firstvxd.asm 

- coff COFF 오브젝트 형식으로 지정한다. 

- c 어셈블만 한다. 링커를 불러서 링크를 실행하지는 않는다. 다른 인자들로 링크를 할 것이기 때문이다. 

- Cx 전역, 공용 라벨의 대소문자를 유지한다. 

- D<text> 텍스트 매크로를 정의한다. 예를 들어 -DBLD_COFF는 BLD_COFF라는 특정 상태의 어셈블리에서 사용하는 텍스트 매크로를 정의한다. 관심이 있다면 인클루드 파일에서 직접 찾아서 어셈블리에 어떤 영향을 주는지 알아볼 수 있다. 위에서는 세가지 스위치들이 정의되었다. BLD_COFF, IS_32, MASM6 이다. C를 안다면 다음과 같음을 알 수 있다. 

#define BLD_COFF 

#define IS_32 

#define MASM6 


link -vxd -def:firstvxd.def firstvxd.obj 

-vxd 오브젝트 파일로 VxD를 만들 것을 지정한다. 

- def:<.DEF file> VxD의 모듈 정의 파일의 이름을 지정한다. 

나는 메이크 파일을 사용하는 것이 더 편리하지만 메이크 파일을 쓰기 싫은 사람은 배치 파일을 써도 된다. 여기 내 메이크 파일이 있다. 

NAME=firstvxd 

$(NAME).vxd:$(NAME).obj 

link -vxd -def:$(NAME).def $(NAME).obj 

$(NAME).obj:$(NAME).asm 

ml -coff -c -Cx -DMASM6 -DBLD_COFF -DIS_32 $(NAME).asm 

== VxD Programming Primer ==
우리는 아무 일도 하지않는 VxD를 만드는 걸 알게되었다.. 이 문서에서 우리는 콘트롤 메시지 핸들러들을 추가해서 좀 더 쓸모있는 걸 만들어보겠다. 

=== VxD 초기화와 종료 ===

VxD는 두가지 형태가 있다. 정적과 동적이다. 각 타입은 로드되는 방법이 다르다. 각기 다른 초기화와 종료 콘트롤 메시지를 받아들인다. 

'''정적 VxD: '''

VMM이 정적 VxD를 로드하는 경우: 

 * 리얼모드로 존재하는 프로그램이 INT 2FH, 1605H를 호출해서 로드할때 
 * VxD가 레지스트리의 다음 키에 써질때: 

HKEY_LOCAL_MACHINE\System\CurrentControlSet\Service\VxD\Key\StaticVxD=pathname 

 * VxD가 system.ini의 [386enh] 섹션에 써있을 때 

device=pathname 

개발 도중에는 system.ini에서 로드하기를 추천한다. VxD에 이상이 있으면 윈도우즈가 시작되지 않을 수 있기 때문에 도스에서 system.ini를 편집하기 위해서다. 레지스트리에서 로드하면 그럴 수 없을 것이다. 

VMM이 정적 VxD를 로드할 때, VxD는 세가지 콘트롤 메시지를 다음 순서로 받게된다. 

 * Sys_Critical_Init VMM은 보호 모드로 전환후 인터럽트를 허용하기 전에 이 콘트롤 메시지를 보낸다. 대부분의 VxD는 다음 경우를 제외하고는 이 메시지를 다룰 필요가 없다. 
   * VxD가 다른 VxD나 보호 모드 프로그램이 호출할 몇몇 인터럽트를 후킹할 때. 이 콘트롤 메시지를 처리할 때 인터럽트가 불가능하기 때문에 후킹되는 인터럽트가 호출되지 않는다는 것을 확실히 알 수 있다. 
   * VxD가 초기화되는 동안 다른 VxD에 의해 호출될 VxD 서비스들을 제공할 때. 예를 들면 당신의 VxD 다음으로 호드되는 어떤 VxD가 Device_Init 콘트롤 메시지가 처리되는 동안 당신의 VxD가 제공하는 서비스를 호출 할 필요가 있을 수 있다. Sys_Critical_Init 메시지가 보내진 후부터 Device_Init 메시지가 오기 전까지 Sys_Critical_Init 메시지에서 서비스를 초기화해야만 한다. 

이 메시지를 처리할 때 가능한 빨리 초기화를 해서 하드웨어 인터럽트들을 잊지 않도록 해야 한다. (기억하자: 인터럽트가 막혀있다) 

 * Device_Init VMM는 인터럽트가 가능해진 다음 이 콘트롤 메시지를 보낸다. 대부분의 VxD는 이 메세지에 대한 응답으로 초기화를 수행한다. 인터럽트가 가능하기 때문에 시간이 많이 소모되는 연산도 하드웨어를 놓칠 걱정없이 실행될 수 있다. (필요하다면)여기서 초기화를 하도록 한다. 
 * Init_Complete 모든 VxD가 Device_Init 메시지를 처리하고 아직 VMM이 모든 초기화 세그먼트 (ICODE 와 RCODE 세그먼트 클래스) 들이 해제되기 전 VMM은 이 콘트롤 메시지를 보낸다. 몇몇 VxD만이 이 메시지를 처리한다. 

VxD는 초기화가 성공했을 때에만 캐리 플래그를 클리어해야 하고 그외에 에러가 생긴 경우는 반환하기 전에 캐리 플래그를 세팅해야 한다. VxD가 초기화를 할 필요가 없을 때는 이 세 메시지를 처리하지 않아도 된다. 

정적 VxD를 정료할 때 VMM은 다음의 콘트롤 메시지를 보낸다. 

 * System_Exit2 VxD가 이 메시지를 받았을 때는 윈도우즈 95가 종료하려 할 때이다. 시스템 VM을 제외한 다음 VM들은 이미 파괴되었을 때이다. 그러나 시피유는 보호모드로 남아있고 시스템 VM에서 안전하게 리얼 모드 코드를 실행할 수 있다. 이때 Kernel32.dll 은 이미 해제되어 있다. 
 * Sys_Critical_Exit2 모든 VxD가 System_Exit2를 처리하고 인터럽트가 막혀있을 때 이 메시지를 받는다. 

시스템을 리얼 모드로 들어가도록 준비하길 원하는 경우를 빼고는 이 두 메시지들을 처리할 필요는 없다. 윈도우즈 95가 종료될 때 리얼모드로 들어간다는 것을 기억해야 한다. So if your VxD did something to the real-mode image that will make it unstable, it should restore the change during this time. (역자: 리얼모드에서 뭔가 해가 될만한 일을 할거면 그걸 기록해놓으라는 소리인 것 같습니다. 직역하면 - 리얼모드 이미지에 뭔가를 해서 불안하게 만들 수 있다면 이 기간동안에 그 변화를 기록해놓아야 한다.) 

여러분은 이 두 종료 메시지의 끝에 "2"가 붙어있는지 궁금할 것이다. VMM이 정적 VxD를 로드할 때 초기화 순서가 작은 순서부터 VxD들을 로드해서 이전에 로드된 VxD의 서비스를 의지할 수 있다는 것을 기억하자. 예를 들며느 VxD2가 VxD1의 서비스에 의지한다면 VxD1보다 초기화 순서를 높게 해야 한다. 로드되는 순서는 이렇게 된다: 

'''.... VxD1 ===> VxD2 ===> VxD3 ....'''

로딩이 해제되는 동안에는 나중에 로드된 VxD가 먼저 해제되어야 한다. 그래야 이전에 로드된 VxD들의 서비스를 호출할 수 있기 때문이다. 위의 예에서는 순서가 이렇게 된다: 

'''.... VxD3 ===> VxD2 ===> VxD1'''

위의 예를 보면 초기화되는 동안 VxD2가 VxD1의 서비스 몇 개를 호출한다면 해제되는 동안에도 VxD1의 서비스에 의지할 수 있을 것이다. System_Exit2 와 Sys_Critical_Exit2 가 reverse initialization order(역자: 초기화 되는 순서의 반대라는 뜻입니다. 우리말로 어떤 용어를 사용하는지 모릅니다.. ) 로 보내진다. 무슨 말이냐면 VxD2가 이 메시지들을 받았을 때는 VxD1가 아직 해제되지 않았고 VxD1의 서비스를 호출할 수 있다는 뜻이다. System_Exit와 Sys_Critical_Exit 메시지들은 reverse initialization order로 보내지지 않는다. 즉 이 두 메시지를 처리할 때 먼저 로드된 VxD의 서비스를 호출 할 수 있는지 장담할 수 없다는 이야기이다. 요즘 VxD들은 이 메시지를 사용하지 않는다. 종료 메시지가 두가지 더 있다: 

 * Device_Reboot_Notify2 VMM이 시스템을 다시 시작한다는 것을 VxD에게 알린다. 인터럽트는 아직 가능한 때이다. 
 * Crit_Reboot_Notify2 VMM이 시스템을 다시 시작한다는 것을 VxD에게 알린다. 인터럽트가 불가능하다. 

이제 Device_Reboot_Notify2 와 Crit_Reboot_Notify 메시지들이 있다는 것을 짐작할 수 있을 것이다. 그러나 "2" 버전처럼 reverse initialization order로 보내지지 않는다. 

'''동적 VxD:'''

동적 VxD는 윈도우즈 9x의 세션동안 동적으로 로드되고 언로드될 수 있다. 이 기능은 윈도우즈 3.x에 없다. 동적 VxD들의 주된 목적은 플러그 앤 플래이 장치같은 동적인 하드웨어가 설치를 지원하는 것이다. 그러나 어플리케이션의 ring 0 확장판으로 여러분의 win32 어플리케이션에서 로드/언로드 할수 있다. 

이전 문서의 예는 정적 VxD였다. .DEF 파일의 VxD 명령행에 DYNAMIC 키워드를 추가해서 동적 VxD로 그 예를 바꿀 수 있다. 

VXD FIRSTVXD DYNAMIC 

정적 VxD를 동적으로 바꾸기 위해 필요한 전부이다. 

동적 VxD는 다음에 의해 로드될 수 있다: 

 * 윈도우즈 폴더의 /SYSTEM/IOSUBSYS에 넣는다. 이 폴더 안의 VxD들은 Input Output Supervisor (IOS) 에 의해 로드된다. 이 폴더안의 VxD들은 layer device driver 들을 지원하기 위한 것이므로 이 방법으로 동적 VxD를 로드하는 것은 적당한 생각이 아니다. 
 * VxD 로더 서비스를 사용한다. VxDLDR 은 동적 VxD들을 도르하기 위한 정적 VxD이다. 다른 VxD나 16비트 코드에서 그 서비스를 호출할 수 있다. 
 * win32 어플리케이션에서 CreateFile API를 호출한다. 밑의 형식의 CreateFile로 정적 VxD를 로드할 수 있다: 

\\.\pathname 

예를 들면, 현재 디렉토리에 있는 FirstVxD라는 동적 VxD를 로드하길 원한다면 다름과 같이 하면 된다: 

{{{
.data 

VxDName db "\\.\FirstVxD.VXD", 0 

.... 

.data? 

hDevice dd? 

.... 

.code 

.... 

invoke CreateFile, addr VxDName, 0, 0, 0, 0, FILE_FLAG_DELETE_ON_CLOSE, 0 

mov hDevice, eax 

.... 

invoke CloseHandle, hDevice 

.... 
}}}

FILE_FLAG_DELETE_ON_CLOSE 플래그는 CreateFile 에 의해 반환된 핸들을 닫을 때 VxD를 언로드하는 한다는 것을 지정한다. 

동적 VxD를 로드할 때 CreateFile를 사용했다면 VxD는 w32_DevideIoControl 메시지를 처리해야 한다. CresteFile 방식으로 처음 로드陖을 때 VWIN32(역자: 윈도우 시스템의 VxD중에 하나입니다) 는 동적 VxD에게 이 메시지를 보낸다. VxD는 이 메시지에 응답하기 위해서 eax에 0을 반환해야 한다. 어플리케이션이 VxD와 통신하기 위해서 DeviceIoControl API를 호출했을 때도 w32_DeviceIoControl 메시지들이 보내진다. 다음 문서에서 DeviceIoControl 인터페이스를 알아볼 것이다. 

동적 VxD는 초기화동안 하나의 메시지를 받는다: 

 * Sys_Dynamic_Device_Init 

그리고 종료될 때 하나의 콘트롤 메시지를 받는다: 

 * Sys_Dynamic_Device_Exit 

동적 VxD는 Sys_Critical_Inti, Device_Init, Init_Complete 콘트롤 메시지를 받지 안는다. 이 메시지들은 시스템 VM이 초기화되는 동안 보내지는 것이기 때문이다. 그 외에 동적 VxD는 메모리에 있는 동안 다른 모든 콘트롤 메시지들을 받는다. 정적 VxD가 할 수 있는 것은 다 할 수 있다. 한마디로 동적 VxD는 다른 방식으로 로드되고 다른 초기화/종료 메시지를 받는 것 외에는 정적 VxD가 할 수 있는 일들을 다 할 수 있다. 

=== 다른 시스템 콘트롤 메시지 ===

VxD가 메모리에 있는 동안 초기화와 종료에 관련된 것들 외에도 많은 콘트롤 메시지를 받는다. 몇 가지는 가상 머신 관리에 관련되 있고 잡다한 이벤트에 관련된 것도 있다. 예를 들면, VM에 관련된 콘트롤 메시지들은: 

 * Create_VM 
 * VM_Critical_Inti 
 * VM_Suspend 
 * VM_Resume 
 * Close_VM_Notify 
 * Destroy_VM 

알아서 관심있는 콘트롤 메시지에 반응하도록 선택하면 된다. 

=== VxD 안에 프로시저 만들기 ===

VxD안의 세그먼트안에 프로시저를 선언한다. 세그먼트를 먼저 선언하고 다음에 프로시저를 안에 집어넣는다. 예를 들어, 함수가 페이지 가능한 세그먼트에 들어가길 원한다면 다음과 같이 페이지 가능 세그먼트를 먼저 정의한다: 

{{{
VxD_PAGEALBE_CODE_SEG 

[Your procedure here] 

VxD_PAGEABLE_CODE_ENDS 
}}}

한 세그먼트 안에 많은 프로시저를 넣을 수가 있다. VxD 작성자는 어떤 세그먼트에 프로시저를 넣을지 결정해야 한다. 프로시저가 하드웨어 인터럽트 핸들러같이 항상 메모리에 있어야 한다면 잠겨진 세그먼트에 넣는다. 아니면 페이지 가능한 세그먼트에 넣는다. 

BeginProc와 EndPRoc 매크로를 가지고 프로시저를 정의한다. 

{{{
BeginProc name 


EndProc name 
}}}

name은 프로시저의 이름이다. BeginPRoc 매크로는 몇가지 파리미터들을 더 가질 수 있다. 자세한 사항은 Win95 DDK 문서를 참고하라. 하지만 대부분은 프로시저의 이름만 가지고 만들 수 있다. 

proc-endp 지시어 대신에 BeginProc-EndProc 매크로를 사용해야 한다. BeginProc-EndProc 매크로는 proc-endp보다 더 많은 기능이 있기 때문이다. 

=== VxD 코딩 컨벤션 ===

'''레지스터의 사용'''

VxD는 어떤 범용 레지스터와 FS, GS를 사용할 수 있다. 하지만 세그먼트 레지스터들을 수정할때는 주의를 해야 한다. 특별히 지금 뭘 하로 있는지 안다고 확신했을 때 아니면 CS와 SS를 바꿔서는 안된다. 복귀했을 때 되돌려 놓기 위해서 DS와 FS에 저장해 놓을 수도 있다. 방향과 인터럽트 플래그: 이 둘은 특별히 중요한다. 긴 시간동안 인터럽트를 막아 놓아서는 안되고 방향 플래그를 수정했으면 반환하기 전에 이전 상태로 되돌려 놓는 것을 잊어서는 안된다. 


'''인자 전달 컨벤션'''

VxD 서비스를 위한 두가지 콜링 컨벤션이 있다. 레지스터 기반과 스택 기반이다. 레지스터 기반 서비스로는 다양한 레지스터들을 통해 서비스로 인자들을 전달 하고 연산이 성공했는지 알기 위해 서비스를 호출 한 후 캐리 플래그를 체크해 볼 수 있다. 서비스를 호출한 후에 범용 레지스터의 값들이 보존되리라고 확신할 수는 없다. 스택 기반 서비스에서는 스택으로 인자들을 푸쉬하고 eax로 반환 값을 받을 수 있다. 스택 기반 서비스들은 ebx, esi, edi, ebp를 보존해야 한다. 대부분의 레지스터 기반 서비스들은 윈도우즈 3.x 시절에서부터 시작된 것들이다. 대부분 이름을 보면 이 두 종류의 서비스들을 구분할 수 있을 것이다. _HeapAllocate 같이 밑줄로 시작하는 서비스의 이름은 스택 기반(C) 서비스이다( VWIN32.VXD에 의해 제공되는 몇가지 서비스들을 제외하고). 서비스 이름이 밑줄로 시작하지 않는다면 레지스터 기반 서비스이다. 


'''VxD 서비스 호출하기 '''

VMMCall과 VxDCall 매크로를 사용해서 VMM과 VxD의 서비스들을 호출 할 수 있다. 두 매크로는 정확히 같은 문법을 가진다. VMM이 제공하는 VxD 서비스들을 호출하길 원할때는 VMMCall를 사용하고 VMM외에 VxD들이 제공하는 서비스를 호출할 때는 VxDCall을 사용한다. 

VMMCall service ; 레지스터 기반 서비스 호출하기 위해 

VMMCall _service, <argument list> ; 스택 기반 서비스를 호출하기 위해 

VMMCall 과 VxDCall 들은 이전 문서에서 설명한 int 20h와 그 뒤의 더블 워드값으로 나눠진다. 하지만 이것들이 더 사용하기 변하다. 스택 기반 서비스들의 경우에는 꺽쇠로 인자 리스트를 감싸야 한다. 

VMMCall _HeapAllocate, <<size mybuffer>, HeapLockedIfDP> 

_HeapAllocate 는 스택 기반 서비스이다. 두 개의 인자를 받는다. 괄호로 감싸야 한다. 그러나 첫 번째 인자는 매크로가 간접적으로 인터프리트할 표현식이므로 우리는 또 다른 꺽쇠안에 두어야 한다. 


=== 플랫 주소 ===

오래된 툴에서는 어셈블러와 링커가 offset 연산자를 썼을 때 잘못된 주소를 생성했다. 그래서 VxD 프로그래머는 offset대신에 offset flat을 사용한다. vmm.inc는 더 간단하게 하기 위한 매크로를 가지고 있다. OFFSET32 는 offset flat로 풀이된다. 그래서 오프셋 연산을 쓰고 싶을때는 대신 OFFSET32를 써야한다. 

note: 이 문서를 쓸 때 offset 연산자를 시험해 봤었다. 바른 주소가 생성되서 MASM6.14에서는 버그가 사라졌다고 생각했다. 하지만 안전하게 하기 위해 바로 offset을 쓰기 보다는 OFFSET32 매크로를 사용하도록 한다. 

== VxD Example: MessageBox ==
이전 문서에서 우리는 VxD 프로그래밍의 기법에 대해서 배웠다. 이제는 배운 것을 적용할 때이다. 이 문서에서는 VM이 생성되거나 파괴될 때 메시지 박스를 출력하는 단순한 정적 VxD를 만들어 본다. 

예제를 다운 받는다. 


=== Trapping VM creation and termination events ===

VM이 생성될 때 VMM은 모든 VxD들에게 Create_VM 콘트롤 메시지를 보낸다. 또한 VM이 정상적으로 종료될 때 모든 VxD들에게 VM_Terminate 와 VM_Terminate2를 보낸다. 할 일은 간단하다. 장치 제어 프로시저에서 Create_VM 와 VM_Terminate2 메시지를 처리하면 된다. VxD가 이 두 메시지를 받았을 때 스크린에 메시지 박스를 출력하면 된다. 

VxD가 Create_VM 이나 VM_Terminate2 메시지를 받았을 때 ebx는 VM의 핸들을 가지게 된다. VM 의 핸들은 VM의 고유한 ID라고 생각하면 된다. 각 VM은 고유한 ID(VM 핸들)을 가지고 있다. VM 핸들을 프로세스 ID를 다루듯이 필요한 서비스의 인자로 전달하면 된다. 

잘 보면, VM 핸들은 사실 VM control block (VMCB)의 32비트 선형 주소이다. VM 콘트롤 블록은 VM에 대한 몇가지 중요한 아이템들을 저장하고 있는 구조체이다. 정의는 다음과 같다. 

{{{
cb_s STRUC 

CB_VM_Status DD ? 

CB_High_Linear DD ? 

CB_Client_Pointer DD ? 

CB_VMID DD ? 

CB_Signature DD ? 

cb_s ENDS 
}}}

 * CB_VM_Status VM의 상태에 대해 알아볼 수 있는 비트 플래그를 가진다. 
 * CB_High_Linear 공유된 시스템 영역 (3GB 상위) 의 미러 이미지의 시작 부분의 선형 주소이다. 이 개념은 설명이 필요하다. 윈도우즈 95에서는 VxD는 V86영역을 직접 접근하지 못했다. 대신에 VMM은 모든 VM의 전체 V86 영역을 공유된 시스템 영역으로 맵핑했다. VxD 가 VM의 V86 영역의 메모리를 수정하거나 접근하려 한다면 VM의 상위 선형 공간에 처리해야 한다. 예를 들어 비디오 메모리가 0B8000h에 있고 VxD가 이 영역을 접근해야 한다면, CB_High_Linear 값에 0B8000h를 더해서 그 영역 대신 접근해야 한다. 상위 선형 미러 이미지에 대한 수정은 두 영역이 같은 페이지 디렉토리 엔트리를 공유하고 있기 때문에 VM에 영향을 주게 된다. 대부분 상위 선형 미러 이미지를 사용하는 것이 더 좋다. 현재 VM이 아닌 VM도 수정할 수 있기 때문이다. 
 * CB_Client_POinter client register structure 의 주소를 가지고 있다. 인터럽트된 VM안의 V86이나 보호 모드 어플리케이션의 모든 레지스터들의 값을 가지고 있는 구조체이다. VxD이 V86이나 PM 어플리케이션의 상태를 알거나 수정하길 원한다면 이 구조체의 멤버들을 수정할 수 있다. VMM이 프로그램을 다시 실행시킬 때 어플리케이션에 변화가 생길 것이다. 
 * CB_VMID VM의 숫자로된 ID이다. VM이 생성될 때 VMM이 할당하게 된다. 시스템 VM의 VMID는 1이 된다. 
 * CB_Signature 문자열 "VMcd"을 가진다. VM 핸들이 정확한지 검사하기 위해 사용한다. 

=== Displaying a MessageBox ===

VxD은 사용자들과 통신하기 위해 Virtual Shell Device를 사용할 수 있다. 그런 서비스 중에 우리가 이 예제에서 사용할 하나가 SHELL_Message 이다. 

SHELL_Message 는 레지스터 기반의 서비스이다. 레지스터를 통해 인자들을 보낸다. 

 * ebx 메시지를 가지는 VM의 핸들 
 * eax MessageBox 플래그들. shell.inc에서 이들을 찾아 볼 수 있다. MB_로 시작한다. 
 * ecx 출력할 메시지의 32비트 선형 주소 
 * edi 메시지 박스 캡션의 32비트 선형 주소 
 * esi 메시지 박스에 응답하는 사용자에 대해 알고자 하는 경우에 사용되는 콜백 함수의 32비트 선형 주소. 알고 싶지 않다면 NULL을 사용한다. 
 * edx (esi를 사용했을 때) 콜백 함수에 전달하고자 하는 데이터의 주소 

반환할 때 호출이 성공했다면 캐리 플래그가 클리어되어야 한다. 아니면 캐리 플래그가 셋된다. 

=== The example ===

{{{
.386p 

include vmm.inc 

include shell.inc 

DECLARE_VIRTUAL_DEVICE MESSAGE,1,0, MESSAGE_Control, UNDEFINED_DEVICE_ID, 

UNDEFINED_INIT_ORDER 

Begin_control_dispatch MESSAGE 

Control_Dispatch Create_VM, OnVMCreate 

Control_Dispatch VM_Terminate2, OnVMClose 

End_control_dispatch MESSAGE 

VxD_PAGEABLE_DATA_SEG 

MsgTitle db "VxD MessageBox",0 

VMCreated db "A VM is created",0 

VMDestroyed db "A VM is destroyed",0 

VxD_PAGEABLE_DATA_ENDS 

VxD_PAGEABLE_CODE_SEG 

BeginProc OnVMCreate 

mov ecx, OFFSET32 VMCreated 

CommonCode: 

VMMCall Get_sys_vm_handle 

mov eax,MB_OK+MB_ICONEXCLAMATION 

mov edi, OFFSET32 MsgTitle 

xor esi,esi 

xor edx,edx 

VxDCall SHELL_Message 

ret 

EndProc OnVMCreate 

BeginProc OnVMClose 

mov ecx,OFFSET32 VMDestroyed 

jmp CommonCode 

EndProc OnVMClose 

VxD_PAGEABLE_CODE_ENDS 

end 


Analysis: 

Begin_control_dispatch MESSAGE 

Control_Dispatch Create_VM, OnVMCreate 

Control_Dispatch VM_Terminate2, OnVMClose 

End_control_dispatch MESSAGE 

}}}

VxD는 Create_VM과 VM_Terminate2, 두 개의 콘트롤 메시지들을 처리한다. Create_VM 콘트롤 메시지를 받았을 때, OnVMCreate 프로시저를 호출한다. VM_Terminate2 메시지를 받았을 때 OnVMClose 프로시저를 호출한다. 

{{{
VxD_PAGEABLE_DATA_SEG 

MsgTitle db "VxD MessageBox", 0 

VMCreated db "A VM is Created", 0 

VMDestroyed db "A VM is destroyed", 0 

VxD_PAGEABLE_DATA_ENDS 
}}}

페이지 가능한 데이터 세그먼트에 데이터를 저장한다. 

{{{
BeginProc OnVMCreate 

mov ecx, OFFSET32 VMCreated 

CommonCode: 

mov eax, MB_OK+MB_ICONEXCLAMATION 

mov edi, OFFSET32 MsgTitle 

xor esi, esi 

xor edi, edi 

VxDCall SHELL_Message 

ret 

endp OnVMCreate 
}}}

OnVMCreate 프로시저는 BeginProc와 Endproc 매크로를 사용해서 만들어진다. ShELL_Message 서비스의 인자들은 레지스터로 들어간다. 시스템 VM안에서 메시지 박스를 출력하길 원하므로 ebx(생성되고 있는 VM의 핸들이 들어있는)의 값을 사용할 수 없다. 대신에 VMM 서비스 Get_Sys_VM_Handle 을 사용해서 시스템 VM의 핸들을 얻을 수 있다. 서비스는 ebx에 핸들을 반환한다. ecx와 edi에 각각 메시지와 캡션의 주소를 저장한다. 유저로부터 응답을 원하지 않으므로 esi와 edx에 0을 쓴다. 모든 인자가 적당한 레지스터에 있으면 메시지 박스를 출력하기 위해 SHELL_Message를 호출한다. 

{{{
BeginProc OnVMClose 

mov ecx, OFFSET32 VMDestroyed 

jmp CommonCode 

endp OnVMClose 
}}}

OnVMClose 프로시저는 그것만으로는 단순하다. OnVMCreate 와 같은 코드를 사용하기 때문에 ecx를 다른 세메지의 주소로 초기화하고 OnVMCreate안의 코드로 점프한다. 

=== Module Definition File ===

VXD MESSAGE 

{{{
SEGMENTS 

_LPTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LDATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_DATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

CONST CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TLS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_BSS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LMGTABLE CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_LMSGDATA CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_IMSGTABLE CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_IMSGDATA CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_ITEXT CLASS 'ICODE' DISCARDABLE 

_IDATA CLASS 'ICODE' DISCARDABLE 

_PTEXT CLASS 'PCODE' NONDISCARDABLE 

_PMSGTABLE CLASS 'MCODE' NONDISCARDABLE IOPL 

_PMSGDATA CLASS 'MCODE' NONDISCARDABLE IOPL 

_PDATA CLASS 'PDATA' NONDISCARDABLE SHARED 

_STEXT CLASS 'SCODE' RESIDENT 

_SDATA CLASS 'SCODE' RESIDENT 

_DBOSTART CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBOCODE CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBODATA CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_16ICODE CLASS '16ICODE' PRELOAD DISCARDABLE 

_RCODE CLASS 'RCODE' 


EXPORTS 


MESSAGE_DDB @1 
}}}

=== Assembling process ===

ml -coff -c -Cx -DMASM6 -DBLD_COFF -DIS_32 message.asm 

link -vxd -def:message.def message.obj 

=== VxD Installation ===

 1. /system 폴더에 message.vxd를 넣는다/ 
 2. system.ini의 [386enh] 섹션 안에 다음 줄을 추가한다. 
    device=message.vxd 
 3. 컴퓨터를 재부팅한다. 

=== Testing the VxD ===

도스 박스를 연다. "A VM is created" 메시지를 출력하는 메시지 박스를 볼 수 있다. 도스 박스를 닫으면 "A VM is destroyed" 메시지의 메시지 박스가 나타난다. 

== DeviceIoControl Interface ==

이 문서에서는 동적 VxD에 대해서 배우겠다. 특별히 생성해서 로드하고 사용하는 방법에 대해 배우겠다. 예제를 다운 받자. 


=== VxD Interfaces ===

VxD는 총 4개의 인터페이스를 제공한다. 

 * VxD services 
 * V86 Interface 
 * Protected-mode (PM) Interface 
 * Win32 DeviceIoControl Interface 

우리는 이미 VxD 서비스에 대해 알고 있다. V86과 PM 인터페이스는 각각 V96과 PM 어플리케이션에서 호출할 수 있는 함수들이다. V86과 PM 어플리케이션이 16 비트이기 때문에 이 두 인터페이스를 win32 어플리케이션에서 사용할 수는 없다. 윈도우즈 95에서 마이크로소프트는 win32 어플리케이션을 위한 또 다른 인터페이스를 추가했다. 그래서 VxD의 서비스를 호출할 수 있다. DeviceIoControl 인터페이스이다. 


=== DeviceIoControl Interface ===

간단히 하면 DeviceIoControl 인터페이스는 WIN32 어플리케이션이 VxD 안의 함수들을 호출하기 위한 방법이다. DeviceIoControl을 통해 호출되는 함수와 VxD 서비스들을 혼돈하면 안된다. 그것들은 다른 것들이다. 예를 들어 DeviceIoControl 함수 1과 VxD 서비스 1은 다를 것이다. DeviceIoControl 함수들을 WIN32 어플리케이션에서만 사용되기 위해 제공되는 다른 부류의 함수들이라고 생각하면 된다. 

인터페이스이기 때문에 두가지 측면이 있다. 


On the win32 application side: 


먼저 VxD를 열고 로드하기 위해서 CreateFile 호출을 한다. 호출이 성공하면 VxD는 메모리에 있을 것이고 CreateFile는 eax에 VxD의 핸들을 반환할 것이다. 

다음으로 실행할 함수를 선택하기 위해 DeviceIoControl API 함수를 호출한다. DeviceIoControl은 다음의 문법을 가진다. 

{{{
DeviceIoControl proto hDevice:dword,\ 

dwIoControlCode:dword,\ 

lpInBuffer:dword,\ 

nInBufferSize:dword,\ 

ipOutBuffer:dword,\ 

nOutBufferSize:dword,\ 

lpBytesReturned:dword,\ 

lpOverlapped:dword 
}}}

 * hDevice CreateFile에서 리턴된 VxD의 한들이다. 
 * dwIoControlCode VxD가 수행해야 하는 연산을 지정하는 값이다. 선택해야 하는 연산이 먼지 알기 위해서는 이전에 어떻게 해서든지 VxD에서 가능한 deIoControlCode 값들의 리스트를 알고 있어야 한다. 그러나 대부분의 경우 본인이 VxD를 코딩한 사람이므로 모든 가능한 dwIoControlCode 값들의 리스트를 알고 있을 것이다. 
 * lpInBuffer dwIoControlCode에서 지정한 연산을 수행하기 위해 VxD가 필요로 하는 데이터들을 가지는 버퍼의 주소이다. 연산이 데이터가 필요없으면 NULL을 보낸다. 
 * nInBufferSize lpInBuffer 가 가리키는 버퍼의 데이터들의 바이트 단위 크기이다. 
 * lpOutBuffer 연산이 성공했을 때 VxD가 출력 데이터로 채울 버퍼의 주소이다. 연산이 아무 데이터도 반환하지 않으면 NULL이 된다. 
 * nOutBufferSize lpOutBuffer가 가리키는 버퍼의 바이트 단위 크기이다. 
 * lpBytesReturned VxD가 lpOutBuffer에 채울 데이터의 크기를 받는 더블 워드 값의 주소이다. 
 * lpOverlapped 연산이 비동기적이 되길 원할 때 사용하는 OVERLAPPED 구조체의 주소이다. 연산이 끝날때까지 기다리길 원한다면 NULL을 채운다. 


=== On the VxD side: ===


w32_deviceIoControl 메시지를 처리해야 한다. VxD가 w32_device_IoControl 메시지를 받았을 때 레지스터들은 다음의 값을 가진다. 

 * ebx VM의 핸들값 
 * esi win32 어플리케이션에서 보내진 정보들을 담고 있는 DIOCParams 구조체의 포인터 

DIOCParams 는 다음과 같이 정의된다. 

{{{
DIOCParams STRUC 

Internal1 DD ? 

VMHandle DD ? 

Internal2 DD ? 

dwIoControlCode DD ? 

lpvInBuffer DD ? 

cbInBuffer DD ? 

lpvOutBuffer DD ? 

cbOutBuffer DD ? 

lpcbBytesReturned DD ? 

lpoOverlapped DD ? 

hDevice DD ? 

tagProcess DD ? 

DIOCParams ENDS 
}}}

 * internal1 win32 어플리케이션의 클라이언트 레지스터 구조체의 포인터 
 * VMHandle 설명할 필요도 없다. 
 * internal2 device descriptor block (DDB) 의 포인터 
 * dwIoControlCode, lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, 

lpcbBytesReturned, lpOverlapped 들은 DeviceIoControl API 호출로 보내질 인자들이다. 

 * hDevice ring-3 디바이스 핸들 
 * tagProces 프로세스 태그 


DIOCParams 구조체로부터 win32 어플리케이션에서 VxD 로 보내진 모든 정보를 얻을 수 있다. VxD는 win32 어플리케이션이 VxD를 열기 위해서 CreateFile을 호출할 때 VWIN32가 VxD로 보내는 DIOC_Open (dwIoControlCode 로 보내지는 값)을 처리해야만 한다. VxD가 준비되었다면 eax에 0을 반환하고 CreateFile 호출은 성공하게 된다. VxD가 준비되지 않았다면 eax에 영이 아닌 값을 반환하고 CreateFile 이 실패하게 된다. DIOC_Open 외에 VxD는 win32 어플리케이션이 디바이스 핸들을 닫을 때 VWIN32 로부터 DIOC_Closehanlde을 받게된다. 


Minimun dynamic VxD skeleton that is loadable by CreateFile 

{{{
.386p 

include vmm.inc 

include vwin32.inc 

DECLARE_VIRTUAL_DEVICE DYNAVXD,1,0, DYNAVXD_Control,\ 

UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER 

Begin_control_dispatch DYNAVXD 

Control_Dispatch w32_DeviceIoControl, OnDeviceIoControl 

End_control_dispatch DYNAVXD 

VxD_PAGEABLE_CODE_SEG 

BeginProc OnDeviceIoControl 

assume esi:ptr DIOCParams 

.if [esi].dwIoControlCode==DIOC_Open 

xor eax,eax 

.endif 

ret 

EndProc OnDeviceIoControl 

VxD_PAGEABLE_CODE_ENDS 

end 



; Module Definition File 




VXD DYNAVXD DYNAMIC 

SEGMENTS 

_LPTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LTEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LDATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TEXT CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_DATA CLASS 'LCODE' PRELOAD NONDISCARDABLE 

CONST CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_TLS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_BSS CLASS 'LCODE' PRELOAD NONDISCARDABLE 

_LMGTABLE CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_LMSGDATA CLASS 'MCODE' PRELOAD NONDISCARDABLE IOPL 

_IMSGTABLE CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_IMSGDATA CLASS 'MCODE' PRELOAD DISCARDABLE IOPL 

_ITEXT CLASS 'ICODE' DISCARDABLE 

_IDATA CLASS 'ICODE' DISCARDABLE 

_PTEXT CLASS 'PCODE' NONDISCARDABLE 

_PMSGTABLE CLASS 'MCODE' NONDISCARDABLE IOPL 

_PMSGDATA CLASS 'MCODE' NONDISCARDABLE IOPL 

_PDATA CLASS 'PDATA' NONDISCARDABLE SHARED 

_STEXT CLASS 'SCODE' RESIDENT 

_SDATA CLASS 'SCODE' RESIDENT 

_DBOSTART CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBOCODE CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_DBODATA CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING 

_16ICODE CLASS '16ICODE' PRELOAD DISCARDABLE 

_RCODE CLASS 'RCODE' 

EXPORTS 

DYNAVXD_DDB @1 
}}}

=== Full Example ===


아래는 동적 VxD를 로드하고 DeviceIoControl API를 통해 VxD의 함수를 호출하는 win32 어플리케이션의 소스 코드이다. 

{{{
; VxDLoader.asm 

.386 

.model flat,stdcall 

include windows.inc 

include kernel32.inc 

includelib kernel32.lib 

include user32.inc 

includelib user32.lib 

.data 

AppName db "DeviceIoControl",0 

VxDName db "\\.\shellmsg.vxd",0 

Success db "The VxD is successfully loaded!",0 

Failure db "The VxD is not loaded!",0 

Unload db "The VxD is now unloaded!",0 

MsgTitle db "DeviceIoControl Example",0 

MsgText db "I'm called from a VxD!",0 

InBuffer dd offset MsgTitle 

dd offset MsgText 

.data? 

hVxD dd ? 

.code 

start: 

invoke CreateFile,addr VxDName,0,0,0,0,FILE_FLAG_DELETE_ON_CLOSE,0 

.if eax!=INVALID_HANDLE_VALUE 

mov hVxD,eax 

invoke MessageBox,NULL,addr Success,addr 

AppName,MB_OK+MB_ICONINFORMATION 

invoke DeviceIoControl,hVxD,1,addr InBuffer,8,NULL,NULL,NULL,NULL 

invoke CloseHandle,hVxD 

invoke MessageBox,NULL,addr Unload,addr 

AppName,MB_OK+MB_ICONINFORMATION 

.else 

invoke MessageBox,NULL,addr Failure,NULL,MB_OK+MB_ICONERROR 

.endif 

invoke ExitProcess,NULL 

end start 
}}}

아래는 vxdloader.asm이 호출할 동적 VxD의 소스 코드이다. 

{{{
; ShellMsg.asm 

.386p 

include vmm.inc 

include vwin32.inc 

include shell.inc 

DECLARE_VIRTUAL_DEVICE SHELLMSG,1,0, SHELLMSG_Control,\ 

UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER 

Begin_control_dispatch SHELLMSG 

Control_Dispatch w32_DeviceIoControl, OnDeviceIoControl 

End_control_dispatch SHELLMSG 

VxD_PAGEABLE_DATA_SEG 

pTitle dd ? 

pMessage dd ? 

VxD_PAGEABLE_DATA_ENDS 

VxD_PAGEABLE_CODE_SEG 

BeginProc OnDeviceIoControl 

assume esi:ptr DIOCParams 

.if [esi].dwIoControlCode==DIOC_Open 

xor eax,eax 

.elseif [esi].dwIoControlCode==1 

mov edi,[esi].lpvInBuffer 

;----------------------------------- 

; copy the message title to buffer 

;----------------------------------- 

VMMCall _lstrlen, <[edi]> 

inc eax 

push eax 

VMMCall _HeapAllocate,<eax,HEAPZEROINIT> 

mov pTitle,eax 

pop eax 

VMMCall _lstrcpyn,<pTitle,[edi],eax> 

;----------------------------------- 

; copy the message text to buffer 

;----------------------------------- 

VMMCall _lstrlen, <[edi+4]> 

inc eax 

push eax 

VMMCall _HeapAllocate,<eax,HEAPZEROINIT> 

mov pMessage,eax 

pop eax 

VMMCall _lstrcpyn,<pMessage,[edi+4],eax> 

mov edi,pTitle 

mov ecx,pMessage 

mov eax,MB_OK 

VMMCall Get_Sys_VM_Handle 

VxDCall SHELL_sysmodal_Message 

VMMCall _HeapFree,pTitle,0 

VMMCall _HeapFree,pMessage,0 

xor eax,eax 

.endif 

ret 

EndProc OnDeviceIoControl 

VxD_PAGEABLE_CODE_ENDS 

end 
}}}

=== Analysis: ===


VxDLoader.asm에서 시작하자. 

{{{
invoke CreateFile, addr VxDName, 0, 0, 0, 0, FILE_FLAG_DELETE_ON_CLOSE, 0 

.if eax != INVALID_HANDLE_VALUE 

mov hVxD, eax 

... 

.else 

invoke MessageBox, NULL, addr Failure, NULL, MB_OK+MN_ICONERROR 

.endif 
}}}

동적 VxD를 로드하기 위해 CreateFile을 호출한다. FILE_FLAG_DELETE_ON_CLOSE 플래그를 눈여겨 보자. 이 플래그는 CreateFile에서 반환된 VxD 핸들이 닫힐 때 윈도우즈가 VxD를 해제하도록 시키게 된다. CreateFile이 성공하면 앞으로 사용하기 위해 VxD 핸들에 저장한다. 

{{{
invoke MessageBox, NULL, addr Success, addr AppName, 

MB_OK+MB_ICONINFORMATION 

invoke DeviceIoControl, hVxD, 1, addr Inbuffer, 8, NULL, NULL, NULL, NULL 

invoke CloseHandle, hVxD 

invoke MessageBox, NULL, addr Unload, addr AppName, 

MB_OK+MB_ICONINFORMATION 
}}}

프로그램은 VxD가 로드되거나 해제될 때 메시지 박스를 출력한다. dwIoControlCode로 1을 보내고 lpInBuffer 인자에 InBuffer의 주소를 보낸다, 그리고 nInBufferSize 에 InBuffer의 크기(8)을 보내서 DeviceIoControl을 호출한다. InBuffer는 두 개의 원소를 가지는 더블 워드의 배열이다. 각각의 원소는 텍스트 스트링의 주소이다. 

{{{
MsgTitle db "DeviceIoControl Example", 0 

MsgText db "I'm called from a VxD!", 0 

InBuffer dd offset MsgTitle 

dd offset MsgText 
}}}

이제 VxD에 관심을 가져보자. 

오직 w32_deviceIoControl 메시지만을 처리할 뿐이다. w32_deviceIoControl 메시지가 보내졌을 때, OnDeviceIoControl 프로시저가 호출된다. 

{{{
BeginProc OnDeviceIoControl 

assume esi:ptr DIOCParams 

.if [esi].dwIoControlCode == DIOC_Open 

xor eax, eax 
}}}

OnDeviceIoControl는 eax에 0을 반환하는 것으로 DIOC_Open을 처리한다. 

{{{
.elseif [esi].dwIoControlCode == 1 

mov edi, [esi].lpvInBuffer 
}}}

콘트롤 코드 1일때 또한 처리한다. 처음으로 하는 일은 DeviceIoControl API 의 lpInBuffer 로 보내지는 두 개의 더블워드 값인 lpvInBuffer 안의 데이터를 추출하는 일이다. 추출을 위해 더블워드 배열의 주소를 edi에 저장한다. 첫 번째 더블 워드는 메시지 박스의 타이틀로 사용될 텍스트의 주소이다. 두 번째 더블 워드는 메시지 박스의 텍스트로 사용될 텍스트이다. 

{{{
;------------------------------- 

:copy the message title to buffer 

;------------------------------- 

VMMCall _lstrlen, <[esi]> 

inc eax 

push eax 

VMMCall _HeapAllocate, <eax, HEAPZEROINIT> 

mov pTitle, eax 

pop eax 

VMMCall _lstrcpyn, <pTitle, [edi], eax> 
}}}

VMM 서비스 _lstrlen을 호출해서 메시지 박스의 타이틀의 길이를 계산한다. eax로 반환된 값이 문자열의 길이이다. 끝에 NULL을 계산하기 위해 길이를 1 증가시켜줬다. 다음으로 _HeapAllocate를 호출해서 끝에 널 문자를 포함한 문자열이 충분히 들어갈 만큼 메모리 블록을 할당해 준다. HEAPZEROINIT 플래그는 _HeapAllocate 가 메모리 블록을 영으로 설정하게 지정한다. 그다음 문자열을 win32 어플리케이션의 주소공간에서 할당된 메모리 블록으로 복사한다. 메시지 박스의 텍스트로 사용할 텍스트 문자열에도 같은 처리를 해준다. 

{{{
mov edi,pTitle 

mov ecx,pMessage 

mov eax,MB_OK 

VMMCall Get_Sys_VM_Handle 

VxDCall SHELL_sysmodal_Message 
}}}

제목과 메시지의 주소를 각각 edi, ecx에 저장한다. eax에 원하는 플래그를 저장하고 Get_Sys_VM_handle를 호출해서 시스템 VM의 VM 핸들을 얻어내고, SHELL_Sysmodal_Message를 호출한다. SHELL_SysModal_Message 는 SHELL_Message의 시스템 모달 버전이다. 메시지 박스에 사용작의 응답이 있을때까지 시스템을 멈춘다. 

{{{
VMMCall _HeapFree, pTitle, 0 

VMMCall _HeapFree, pMessage, 0 
}}}

SHELL_Sysmodal_Message 가 반환되면 _HeapFree를 호출해서 메모리 블록을 해제한다. 


=== Conclusion ===

DeviceIoControl 인터페이스는 동적 VxD를 win32 어플리케이션의 ring-0 DLL 로의 확장처럼 사용하면 된다는 개념이 된다. 

== Application Time and Shell Functions ==

어플리케이션 시간은 "appy time" 이라고 불린다. 시스템 VM이 VxD와 ring3 어플리케이션이 서로 소통할 수 있을 만큼 특히 16비트 어플리케이션에도 마찬가지로 충분히 안정적인 때를 나타낸다. 예를 들면 어플리케이션 시간에는 VxD가 로드되고 16 비트 DLL 안의 함수를 호출할 수 있다. 이 어플리케이션 시간은 윈도우즈 3.1에서는 허용되지 않았었다. 윈도우즈 3.1 에서는 VxD가 16비트 DLL의 어떠한 함수라도 주소를 확보할 수 있었고 그 주소로의 원거리 점프를 시뮬레이트 할 수 있었다. 그러나 VMM의 재진입때문에 ring 3 어플리케이션이 어떤 일을 하고 있던지 인터럽트 할 수 있게 되었다. 결국 PostMessage 처럼 VxD가 호출할 수 있는 API 들만이 인터럽트에서 안전하게 되었다. 간단하게 말해 VxD가 지금이 어플리케이션 시간이라고 통보받으면 16비트 DLL을 로드하고 그 안의 함수들을 호출할 수 있다는 것이다. 그러면 VxD는 어떻게 어플리케이션 시간이 陖는지 알 수 있을까? Shell VxD에 콜벡 함수를 등록해야 한다. 시스템 VM이 안정한 상태가 되면 Shell VxD는 VxD가 어플리케이션 시간 이벤트를 위해 등록했던 콜벡 함수를 호출하게 된다. Shell VxD는 어플리케이션 시간 이벤트에서 오직 한번만 등록된 콜벡 함수를 호출한다. 직업을 구하는 것과 비슷한다. 직업 알선소에 가서 이름과 전화번호를 등록한다. 그리고 집에 간다. 일이 찾아지면 알선소는 소식을 전해주게 된다. 한번 소식을 접하면 알선소는 더 이상 전화를 하지 않게 된다. 어플리케이션 시간 이벤트가 생기가 전에 약간의 시간이 걸린다. 어플리케이션 시간 이벤트는 다음과 같은 상황에서는 생기지 않는다. 

 * 시스템 시작/ 종료시 
 * 시스템 VM이 임계영역에 있거나 세마포어를 기다리고 있을 때 

=== Managing an appy time event ===

_SHELL_CallAtAppyTime 함수로 어플리케이션 시간 이벤트에 등록할 수 있다. 다음과 같이 정의된다. 


VxDCall _SHELL_CallAtAppyTime, <<OFFSET32 pfnCallback>, dwRefData, dwFlags, dwTimeout> 

'''pfnCallBack'''

어플리케이션 시간 이벤트가 발생했을 때 Shell VxD가 호출할 콜벡 함수의 선형 주소이다. 이 함수는 dwRefData와 dwFlags 두 인자를 받는데 이는 _SHELL_CallAtAppyTime 에 보내는 두 인자와 완전히 동일하다. Shell VxD는 콜벡 함수는 C 콜링 컨벤션으로 호출하는 것을 주의하자. 간단히 말해 이와 같이 콜벡 함수를 정의해야 한다는 것이다. 

{{{
BeginProc OnAppyTime, CCALL, PUBLIC 

ArgVar dwRefData, DWORD ; declare argument name and type 

ArgVar dwFlags, DWORD 

EnterProc 


< Your code here > 


LeaveProc 

Return 

EndProc OnAppyTime
}}}

'''dwRefData'''

Shell VxD가 콜벡 함수로 전달할 참조 데이터. 원하는 것은 뭐든지 될 수 있다.

'''dwFlags'''

이벤트 플래그. 다음의 값들이 될 수 있다. 

CAAFL_RING0 Ring zero event. 

CAAFL_TIMEOUT dwTimeOut 으로 지정된 시간 이후에 이벤트는 시간 초과가 된다. 

단순히 말해 일정 기간동안에만 어플리케이션 시간 이벤트를 기다리길 원한다면 CAAFL_TIMEOUT 플래그를 사용해라. 어플리케이션 시간 이벤트을 무한히 기다리길 원한다면 NULL을 사용한다. CAAFL_RING0 가 실제로 무엇을 의미하는 지는 잘 모른다.

'''dwTimeOut'''

VxD가 어플리케이션 시간 이벤트의 발생을 기다리는 시간. 나는 이 인자에 사용회는 시간 단위에 대해 어떤 정보도 찾을 수 없었다.

이 서비스는 비동기적이다. 어플리케이션 시간 이벤트를 위해 콜벡 함수를 등록한 직후에 반환될 수 있다는 의미이다. 

이 서비스 호출이 성공하면 eax에 어플리케이션 시간 이벤트 핸들을 반환한다. 실패하면 eax는 0이 된다. 어플리케이션 시간 등록을 _SHELL_CancleAppyTimeEvent 로 취소할 수 있는데 이는 _SHELL_CallAtAppyTime 가 반환하는 어플리케이션 시간 이벤트 핸들 하나만을 인자로 갖는다. 

안전을 위해서는 _SHELL_CallAtAppyTime를 호출하기 전에 어플리케이션 시간 이벤트가 허용되는지에 대해 시스템을 체크해봐야 한다. 예를 들면, 시스템이 종료되고 있는 동안에 어플리케이션 시간 이벤트를 등록한다면 어찌 되겠는가? VxD의 콜벡은 절대 호출되지 않을 것이다! _SHELL_QueryAppyTimeAvailable을 호출해서 어플리케이션 시간 이벤트가 허용되는지에 대해 시스템에 알아볼 수 있다. 이 서비스는 인자가 필요없다. 어플리케이션 시간 이벤트가 허용되지 않으면 eax에 0을 반환한다. 즉 시스템의 종료되고 있거나 메시지 서버가 GP 폴트를 일으켰을 때이다. 이 서비스는 지금이 어플리케이션 시간이라고 알려주지는 않는다. 오직 어플리케이션 시간 이벤트가 있을 거라고만 알려준다. 간단히 말하면 안전하게 만드려면 _SHELL_QueryAppyTimeAvailable을 먼저 호출하고 eax에 0이 아닌 값을 반환하면 _SHELL_CallAtAppyTime을 호출할 수 있다는 것이다. 

=== Application-time Shell Service ===

어플리케이션 시간이 되었을 때 호출할 수 있는 몇가지 Shell 서비스가 있다. 

 * _SHELL_CallDll 
 * _SHELL_FreeLibrary 
 * _SHELL_GetProcAddress 
 * _SHELL_LoadLibrary 
 * _SHELL_LocalAllocEx 
 * _SHELL_LocalFree 

이 여섯가지 함수가 제공되기 때문에 VxD 들은 16비트 DLL/ExE 안의 16비트 함수들을 호출 할 수 있다. WinHelp같은 것들이다. 그러나 32비트로 넘어가야 하기 때문에 (미래에는 64비트가 될 것이다.) 여기에 대해서는 자세히 알아보지 않을 것이다. 관심이 있다면 윈도우즈 95/98 DDK 문서에서 그것들에 관해 읽어볼 수 있다. 

내가 생각하기에 어플리케이션 시간에 사용할 좀더 유용한 SHELL 서비스들이 더 있다. _SHELL_ShellExecute 와 _SHELL_BroadcastSystemMessage 이다. 

_SHELL_BreadcastSystemMessage로는 최고 레벨 윈도우즈와 모든 VxD들에게 메시지를 보낼 수 있다. 어플리케이션 시간이 허용되지 않았으면 VxD들에게만 메시지를 보낼 수 있다. _SHELL_ShellExecute 는 ring 3의 ShellExecute 함수와 쌍이 된다. 실지로는 ring 3 ShellExecute를 호출해서 일을 한다. 이 Shell 서비스로 어떤 파일이든지 실행하거나 열거나 프린트 할 수 있다. _SHELL_ShellExecute 는 다음과 같이 정의된다. 


VxDCall _SHELL_ShellExecute, <OFFSET32 ShexPacket> 


SHEXPACKET 구조체의 선형 주소 하나만을 인자로 사용한다. eax에 값을 반환한다. 다음으로 SHEXPACKET 구조체를 알아보자. 

'''shex_dwTotalSize'''

SHEXPACKET 구조체의 바이트 단위 크기에 옵션으로 rgchBaggage 인자를 더한 것이다. rgchBaggage인자는 구조체의 바로 다음에 있게 된다. rgchBaggage에 대해서 간단히 설명할 것이다.

'''shex_dwSize'''

SHEXPACKET 구조체의 바이트 단위 크기인데 rgchBaggage를 더하지 않는다. 위의 shex_dwTotalSize 와 함께 쉘 VxD가 rgchBaggage의 길이를 계산하는데 사용된다. rgchBaggage는 길이가 가변적이기 때문이다.

'''shex_ibOp'''

실행하기 원하는 연산이다. 만약 0을 지정하면 파일을 열길 원한다는 뜻이 된다. 파일이 실행 파일이면 실행이 된다. 다른 연산을 원한다면 rhchBaggage 안에 연산의 이름을 지정하고 이 필드를 SHEXPACKET 구조체의 시작부터 ASCIIZ 문자열의 첫 번째 문자까지의 거리로 지정한다. 그 문자열은 수행할 연산의 이름을 가지고 있어야 한다. SHEXPACKET 의 크기는 32 바이트이다. 연산의 문자열이 SHEXPACKET 구조체의 바로 뒤에 온다면 shex_ibOp 의 값은 32가 되어야 한다. 수행할 수 있는 연산들에 대한 리스트를 운한다면 ShellExecute를 체크해본다. 세가지 연산이 정의되어 있다. "open", "print", "explore".

'''shex_ibFile'''

이 구조체에서부터 ShellExecute로 보낼 파일 이름인 ASCIIZ 문자열까지의 상대적인 거리. shex_ibOp 과 아주 비슷하다.

'''shex_ibParams'''

shex_ibFiledp 지정된 파일에 보낼 옵션 인자이다. 만약 파일이 문서이거나 인자를 전달하지 않을 것이라면 0을 사용한다. 파일에 몇가지 인자를 전달하길 원한다면 이 구조체 이후 어딘가에 문자열로 된 인자를 지정하고 구조체와 문자열의 상대적인 거리를 이 필드에 저장한다. 간단히 말해 shex_ibOp와 shex_ibFile 와 아주 비슷하다.

'''shex_ibDir'''

워킹 디렉토리. 윈도우즈 디렉토리를 사용한다면 0을 지정하고 아니면 이 구조체 다음에 디렉토리 문자열을 지정하고 구조체와 문자열의 상대 거리를 이 필드에 지정한다.

'''shex_dwReserved'''

이름이 알려주듯이 예약된 것이다. 혼란스러워 하지 말자.

'''shex_nCmdShow'''

어플리케이션 윈도우가 어떻게 나타날지에 대한 것이다. ShowWindow에 보통 전달하는 값들이다. 즉 SW_XXXX 값이다. windows.inc에서 값들을 찾아볼 수 있다.


모든 멤버들은 DWORD 사이즈이다. 그럼 설명하겠다고 약속한 rgchBaggage 멤버는 어디에 있는가? 설명하기가 약간 어렵다. rgchBaggage 는 SHEXPACKET 구조체의 멤버이긴 하지만 구조체의 정의에 들어있지는 않다. 그 크기가 가변적이기 때문이다. shell.inc를 확인해봐도 SHEXPACKET 의 정의에 포함되어있지 않다. 하지만 윈도우즈 9x DDK 문서에는 SHEXPACKET 의 멤버라고 말하고 있긴 하다. rgchBaggage 는 무었인가? 단순히 SHEXPACKET 구조체 다음에 나오는 ASCIIZ 문자열의 배열이다. 이 배열 안에는 파일에 수행할 연산의 이름을 저장할 수 있고 파일의 이름이나 파일에 전달할 인자나 워킹 디렉토리를 저장할 수 있다. SHELL VxD는 SHEXPACKET 구조체의 선형 오프셋에다가 문자열의 상대 오프셋을 더해서 rgchBaggage의 오프셋을 알아낸다. 예를 들면 SHEXPACKET 구조체가 60000h에서 시작하고 문자열이 구조체의 바로 뒤에 온다면 문자열과 구조체의 거리는 구조체의 크기가 되므로 32바이트 (20h) 가 된다. 그래서 Shell VxD는 문자열이 주소 60020h에 있다는 것을 알게 된다. 

=== The Example ===

이것은 어플리케이션 시간 이벤트에 어떻게 등록하고 _SHELL_ShellExecute를 사용하는지에 대해 보여주는 아주 단순한 예이다. VxD는 WIN32 어플리케이션이 로드하는 동적 VxD이다. 사용자가 "run Calculator" 버튼을 누르면 win32 어플은 DeviceIoControl을 호출해서 VxD가 어플리케이션 시간 이벤트를 등록하게 할 것이고 윈도우즈 디렉토리에 있는 calc.exe를 실행시킬 것이다. 

{{{
;--------------------------------------------------------------------------------- 
; VxD Source Code 
;--------------------------------------------------------------------------------- 


.386p 

include \masm\include\vmm.inc 

include \masm\include\vwin32.inc 

include \masm\include\shell.inc 


VxDName TEXTEQU <VXDEXEC> 

ControlName TEXTEQU <VXDEXEC_Control> 

VxDMajorVersion TEXTEQU <1> 

VxDMinorVersion TEXTEQU <0> 



VxD_STATIC_DATA_SEG 

VxD_STATIC_DATA_ENDS 


VXD_LOCKED_CODE_SEG 

;---------------------------------------------------------------------------- 

; Remember: The name of the vxd MUST be uppercase else it won't work/unload 

;---------------------------------------------------------------------------- 

DECLARE_VIRTUAL_DEVICE %VxDName,%VxDMajorVersion,%VxDMinorVersion, 

%ControlName,UNDEFINED_DEVICE_ID,UNDEFINED_INIT_ORDER 

Begin_control_dispatch %VxDName 

Control_Dispatch W32_DEVICEIOCONTROL, OnDeviceIoControl 

End_control_dispatch %VxDName 


BeginProc OnDeviceIoControl 

assume esi:ptr DIOCParams 

.if [esi].dwIoControlCode==1 

VxDCall _SHELL_CallAtAppyTime,<<OFFSET32 OnAppyTime>,0,0,0> 

.endif 

xor eax,eax 

ret 

EndProc OnDeviceIoControl 

VXD_LOCKED_CODE_ENDS 



VXD_PAGEABLE_CODE_SEG 

BeginProc OnAppyTime, CCALL 

ArgVar RefData,DWORD 

ArgVar TheFlag,DWORD 

EnterProc 

mov File.shex_dwTotalSize,sizeof SHEXPACKET 

add File.shex_dwTotalSize,sizeof EXEName 

mov File.shex_dwSize,sizeof SHEXPACKET 

mov File.shex_ibOp,0 

mov File.shex_ibFile,sizeof SHEXPACKET 

mov File.shex_ibParams,0 

mov File.shex_ibDir,0 

mov File.shex_dwReserved,0 

mov File.shex_nCmdShow,1 

VxDCall _SHELL_ShellExecute, <OFFSET32 File> 

LeaveProc 

Return 

EndProc OnAppyTime 

VXD_PAGEABLE_CODE_ENDS 



VXD_PAGEABLE_DATA_SEG 

File SHEXPACKET <> 

EXEName db "calc.exe",0 

VXD_PAGEABLE_DATA_ENDS 


end 
}}}

=== Analysis ===

VxDsmsDeviceIoControl 메시지 서비스 번호 1을 기다린다. 메시지를 받았을 때 어플리케이션 시간 이벤트를 등록하게 된다. 


VxDCall _SHELL_CallAtAppyTime, <<OFFSET32, OnAppyTime>, 0, 0, 0> 


OnAppyTime 함수의 선형 주소를 _SHELL_CallAtAppyTime 에 전달해서 Shell VxD는 어플리케이션 시간 이벤트가 발생했을 때 호출하게 된다. 참조 데이터를 사용하지 않았고 대기 시간도 필요 없으므로 OnAppyTime의 선형 주소 다음에 나오는 세 인자 모두 0이다. 

어플리케이션 시간 이벤트가 발생했을 때 Shell VxD는 OnAppyTime 함수를 호출하게 된다. 


BeginProc OnAppyTime, CCALL 


BeginProc로 함수를 선언한다. Shell VxD가 OnAppyTime 함수를 C 콜링 컨벤션으로 호출하므로 CCALL 속성을 지정해야 할 필요가 있다. 

{{{
ArgVar RefData, DWORD 

ArgVar TheFlag, DWORD 

EnterProc 

... 

LeaveProc 

Return 
}}}

Shell VxD가 두 개의 인자를 가지고 OnAppyTime을 호출하므로 그에 따라 스택 프레임을 설정해야 한다. ArgVar 매크로는 함수에 전달될 각 인자를 위한 스택 프레임을 조정한다. 문법은 다음과 같다. 


ArgVar varname, size, used 


varname 은 인자의 이름이다. 원하는 이름 아무거나 사용한다. size는 물론 인자의 바이트 단위 크기이다. BYTE, WORD, DWORD나 1, 2, 4를 사용할 수 있다. used는 보통 생략한다. ArgVar 매크로 바로 다음으로 EnterProc와 LeaveProc 매크로를 사용해서 프로시저의 명령어들이 시작되고 끝나는 것을 나타내어 줄 필요가 있다. 그래서 지역 변수와 인자들이 바로 접근되게 말이다. Return 매크로를 호출자에게 반환하는데 사용한다. 

{{{
mov File.shex_dwTotalSize,sizeof SHEXPACKET 

add File.shex_dwTotalSize,sizeof EXEName 

mov File.shex_dwSize,sizeof SHEXPACKET 

mov File.shex_ibOp,0 

mov File.shex_ibFile,sizeof SHEXPACKET 

mov File.shex_ibParams,0 

mov File.shex_ibDir,0 

mov File.shex_dwReserved,0 

mov File.shex_nCmdShow,1 

VxDCall _SHELL_ShellExecute, <OFFSET32 File> 
}}}

프로시저 안의 이 명령어들은 단순하다. SHEXPACKET 구조체를 초기화하고 _SHELL_ShellExecute 서비스를 호출한다. shex_dwTotalSize가 SHEXPACKET 구조체 자신과 뒤따라오는 문자열의 크기를 더한 것임을 주목하자. 이것은 간단한 경우이다. 문자열이 구조체의 바로 다음에 오지 않는다면 구조체의 첫 바이트와 문자열의 마지막 바이트의 거리를 직접 계산해야만 한다. shex_ibFile 은 구조체 자신만의 크기를 가지고 있다. 구조체의 바로 다음에 프로그램의 이름이 있기 때문이다. shex_ibDir은 0인데 워킹 디렉토리로 윈도우즈 디렉토리를 사용할 것이라는 걸 나타낸다. 프로그램이 윈도우즈 디렉토리만 있어야 한다는 것을 말하는 것이 아니다. 프로그램은 윈도우즈가 찾아낼 수 있으면 어디에 있는지 상관없다. shex_nCmdShow 은 SW_SHOWNORMAL의 값인 1이다. 

{{{
File SHEXPACKET <> 

EXEName db "calc.exe", 0 
}}}

SHEXPACKET 구조체 바로 다음으로 우리가 실행할 프로그램의 이름을 정의했다. 

== Client Register Structure ==

이 문서에서는 Client register structure 라는 이름의 중요한 구조체를 하나 알아볼 것이다. 

=== Some Theory ===

VxD들은 win32/win16/DOS 어플리케이션들과 매우 다르다. VxD들은 다른 보통 어플들이 자신들의 일을 하는 대부분의 시간 동안은 잠들어 있다. 그것들은 다른 ring 3 어플들을 살펴보는 감독관같이 행동하고 뭔가 잘못된 행동을 하면 바로잡는다. 보통 진행과정은 다음과 같다. 

 1. 인터럽트 발생한다 
 2. VMM이 콘트롤을 시작한다 
 3. VMM이 레지스터의 값들을 저장한다. 
 4. VMM이 인터럽트에 서비스를 하거나 다른 일을 위해 VxD를 호출한다. 

위에서 재미있는 것은 VMM이 인터럽트된 어플에 영향을 주는 유일한 방법은 저장된 레지스터의 이미지를 수정하는 것 뿐이라는 것이다. 예를 들어 VMM이 인터럽트된 프로그램이 다른 주소에서 실행을 다시 시작되야 한다고 생각하면 저장된 레지스터의 이미지에서 CS:IP 의 값을 수정할 수 있고 프로그램이 다시 실행될 때는 새로운 CS:IP에서 다시 실행이 시작되게 된다. 

VMM은 인터럽트 된 시점의 레지스터 값들을 client register structure 안에 저장한다. 

{{{
Client_Reg_Struc STRUC 

Client_EDI DD ? 

Client_ESI DD ? 

Client_EBP DD ? 

Client_res0 DD ? 

Client_EBX DD ? 

Client_EDX DD ? 

Client_ECX DD ? 

Client_EAX DD ? 

Client_Error DD ? 

Client_EIP DD ? 

Client_CS DW ? 

Client_res1 DW ? 

Client_EFlags DD ? 

Client_ESP DD ? 

Client_SS DW ? 

Client_res2 DW ? 

Client_ES DW ? 

Client_res3 DW ? 

Client_DS DW ? 

Client_res4 DW ? 

Client_FS DW ? 

Client_res5 DW ? 

Client_GS DW ? 

Client_res6 DW ? 

Client_Alt_EIP DD ? 

Client_Alt_CS DW ? 

Client_res7 DW ? 

Client_Alt_EFlags DD ? 

Client_Alt_ESP DD ? 

Client_Alt_SS DW ? 

Client_res8 DW ? 

Client_Alt_ES DW ? 

Client_res9 DW ? 

Client_Alt_DS DW ? 

Client_res10 DW ? 

Client_Alt_FS DW ? 

Client_res11 DW ? 

Client_Alt_GS DW ? 

Client_res12 DW ? 

Client_Reg_Struc ENDS 
}}}

이 구조체 안에 두 종료의 멤버들이 있다는 것을 볼 수 있다. Client_xxx 와 Client_Alt_xxx 이다. 이것은 약간의 설명이 필요하다. VM에서 실행중인 두 개의 쓰레드가 있을 수 있다. V86과 보호 모드이다. V86 프로그램이 활동할 때 인터럽트가 발생하면 Client_xxx 이 V86 프로그램의 레지스터들의 이미지를 가지게 되고 Client_Alt_xxx가 PM 프로그램의 레지스터들의 값들을 가지게 된다. 교대로 PM 프로그램이 활동할 때 인터럽트가 발생했으면 Client_xxx이 PM 프로그램의 레지스터들의 값들을 가지게 되고 Client_Alt_xxx가 V86 프로그램의 레지스터들을 가지게 된다. Client_resX 들은 예약되어 있고 사용되지 않는다. 

구조체를 알아보고 나면 어떤 의문이 들 것이다. 레지스터의 한 바이트만 말하자면 al을 바꾸려고 할 때는 무엇을 해야 하나? 위의 구조체는 오직 워드와 더블 워드 사이트의 레지스터들을 그리고 있다. 걱정할 필요가 없다. vmm.inc의 안을 들여다보자. 이런 목적을 위해 두가지 구조체가 더 있다. Client_Word_Reg_Struc와 Client_Byte_Reg_Struc이다. 워드나 바이트 크기의 레지스터를 접근하기 원한다면 필요에 따라 Client_Reg_Struc를 Client_Word_Reg_Sturc 이나 Client_Byte_Reg_Struc 으로 타입캐스팅을 해서 사용한다. 


The Next question: How can we obtain the pointer to the client register structure? 


사실 쉽다. 대부분의 경우 VMM은 VxD를 호출할 때 client register structure 의 주소를 ebp 에 저장한다. 이 경우에 client register structure 는 현재 VM의 것이다. 바꿔서 VM 핸들에서 이 포인터를 얻어낼 수도 있다. VM 핸들이 사실 VM control block 의 선형 주소라는 것을 기억하자. 

{{{
cb_s STRUC 

CB_VM_Status dd ? 

CB_High_Linear dd ? 

CB_Client_Pointer dd ? 

CB_VMID dd ? 

CB_Signature dd ? 

cb_s ENDS 
}}}

CB_Client_Pointer는 해당 VM의 client register structure의 포인터를 가지고 있다. 예를 들어 다음과 같은 코드로 현재 VM의 client register structure의 포인터를 얻어낼 수 있다. 

{{{
VMMCall Get_Cur_VM_Handle ; ebx에 연재 VM의 핸들을 반환한다. 

assume ebx:ptr cb_s 

mov ebp, [ebx+CB_Client_Pointer] ; client register structure 의 포인터 
}}}

이제 client register structure를 이해했으면 사용하는 것으로 넘어가자. 우리는 MS-DOS 인터럽트 int 21h 서비스 2h , 문자 출력 서비스를 위한 레지스터에 값을 전달하는 데 client register structure를 사용할 것이다. MS-DOS 서비스는 dl에 출력할 문자를 가진다. 이 서비스에 벨 문자 (07h)를 전달하면 PC 스피커를 통해 벨을 출력할 수 있다. 

int 21h 가 V86 모드에서 가능한 MS-DOS 서비스라는 것을 기억하자. 어떻게 하면 VxD에서 V86 인터럽트를 호출 할 수 있을까? 한가지 방법은 Exec_Int 서비스를 사용하는 것이다. 이 VMM 서비스는 호출될 인터럽트 번호를 eax에 가진다. 그것은 특정 인터럽트를 시물레이트해주고 VM의 실행을 재개한다. 그러나 따로 묶여진 실행 블록안에서 호출되어야 한다. 이 실행 블록은 Begin_Nest_V86_Exec (아니면 Begin_Nest_Exec) 와 End_Nest_Exec로 묶여야 한다. 그래서 int 21h 서비스 2를 호출하기 원한다면 그 묶여진 실행 블록안에서 Client_Byte_Reg_Struc 구조체의 Client_ah 와 Client_Dl을 수정해야 한다. 그리고 ex에 21h 값을 저장하면 된다. 모든게 준비陖으면 Exec_Int를 호출한다. 

=== The Example ===

PC 스피커를 플레이하기 위해 int 21h 서비스 2를 실행하는 동적 VxD의 예제이다. 

{{{
.386p 

include \masm\include\vmm.inc 

include \masm\include\vwin32.inc 

include \masm\include\v86mmgr.inc 



VxDName TEXTEQU <VXDINT> 

ControlName TEXTEQU <VXDINT_Control> 

VxDMajorVersion TEXTEQU <1> 

VxDMinorVersion TEXTEQU <0> 



VxD_STATIC_DATA_SEG 

VxD_STATIC_DATA_ENDS 



VXD_LOCKED_CODE_SEG 

;---------------------------------------------------------------------------- 

; 기억하자 : VxD의 이름이 대문자가 아니면 로드되지 않거나 실행되지 않는다. 

;---------------------------------------------------------------------------- 

DECLARE_VIRTUAL_DEVICE %VxDName,%VxDMajorVersion,%VxDMinorVersion, 

%ControlName,UNDEFINED_DEVICE_ID,UNDEFINED_INIT_ORDER 


Begin_control_dispatch %VxDName 

Control_Dispatch W32_DEVICEIOCONTROL, OnDeviceIoControl 

End_control_dispatch %VxDName 


VXD_LOCKED_CODE_ENDS 



VXD_PAGEABLE_CODE_SEG 


BeginProc OnDeviceIoControl 

assume esi:ptr DIOCParams 

.if [esi].dwIoControlCode==1 

Push_Client_State 

VMMCall Begin_Nest_V86_Exec 

assume ebp:ptr Client_Byte_Reg_Struc 

mov [ebp].Client_dl,7 

mov [ebp].Client_ah,2 

mov eax,21h 

VMMCall Exec_Int 

VMMCall End_Nest_Exec 

Pop_Client_State 

EndI: 

.endif 

xor eax,eax 

ret 

EndProc OnDeviceIoControl 


VXD_PAGEABLE_CODE_ENDS 


end 
}}}

=== Analysis ===

별로 설명할게 없다. VxD가 DeviceIoControl 메시지를 받았을 때 ebp는 이미 현재 VM의 client register structure를 가지키고 있다. client register의 현재 상태를 스택에 저장하기 위해서 Push_Client_State 매크로를 호출한다. 나중에 client register 의 복구하기 위해서 Pop_Client_State를 호출할 것이다. 


VMMCall Begin_Nest_V86_Exec 


Bigin_Nest_V86_Exec를 호출해서 묶여진 실행 블록을 시작한다. 

{{{
assume ebp:ptr Client_Byte_Reg_Struc 

mov [ebp].Client_dl, 7 

mov [ebp].Client_ah, 2 
}}}

client register structure 의 dl과 ah레지스터 이미지를 변경한다. 바뀐 값은 인터럽트에 사용된다. 

{{{
mov eax, 21h 

VMMCall Exec_Int 
}}}

Exec_Int 는 인터럽트 번호가 eax에 있다고 생각한다. int 21h를 실행할 것이다. 다음으로 인터럽트를 시물레이트하기 위해 Exec_Int를 호출한다. 

{{{
VMMCall End_Nest_Exec 

Pop_Client_State 
}}}

Exec_Int 가 반환할 때 우리는 묶여진 실행 블록을 종료하고 client register 의 저장된 값들을 스택에서 복구한다. 

PC 스피커에서 벨이 울리는 것을 들을 수 있을 것이다. 
