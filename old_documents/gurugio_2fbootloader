= 단순한 부트로더 제작 =

The simplest bootloader by gurugio

1st edition, Jan, 2002

''Gi-Oh Kim, www.asmlove.co.kr''

[[TableOfContents]]

== What is Bootloader? ==
부트 로더는 보통 하드 디스크의 MBR(Master Boot Record)에 저장되어 있다. 이것은 하드디스크의 물리적인 위치에서 가장 첫번째 섹터를 말하며 플로피 디스크로 부팅할때는 플로피 디스크의 가장 첫 섹터를 말하게 된다. 보통 리눅스에서 사용하는 LILO나 GRUB, WINDOWS 2000에서 사용하는 NT loader가 부트로더이다. 이것은 컴퓨터의 부팅시에 아무 정보도 저장되어있지 않은 메모리에 운영체제의 시동을 위한 정보를 하드에서 읽어와서 메모리로 적재하는 일을 한다. 정확하게 말하면 바이오스가 하드디스크의 첫 섹터를 읽어서 메모리에 올려놓고 EIP를 이 프로그램의 시작 위치에 맞춰놓게 되고 그러면 이 프로그램은 운영체제의 핵심 부분 즉 커널을 하드에서 읽어들여서 메모리에 올려놓고 그곳으로 점프 – 즉 또다시 EIP를 커널의 시작 부분에 맞추게 되는 – 하게 된다.

왜 바로 바이오스가 커널을 실행하지 않고 이런 이중의 수고를 해야하는지 궁금하다면 리눅스와 윈도우를 같이 쓰거나 리눅스 커널의 여러가지 버전을 사용해보는 것이 좋겠다. 아니면 윈도우즈도 여러가지  버전을 한 피시에서 사용해보면 잘 알수 있을 것이다.

== Why do I make bootloader? ==
운영체제의 커널을 제작하기 위한 모임에서 가장 먼저 시도한 것이 부트 시퀀스에 관한 스터디였고 그에따라 커널을 로드하기 위한 기본적인 도구들을 제작하기 시작했다. 그 일부분으로 부트로더를 제작하게 되었다.

보통 커널을 자체 제작할 때 그 시작을 부트로더부터 하는 경우가 많다. 이는 우선 커널을 만들었을 때 테스트 환경을 구축하기 위함이다.

== The simplest bootloader == 
부트로더가 해야하는 일들중 가장 중요하고 꼭 필요한 일들만 설명하면 다음과 같다.

 1. 자신의 소스의 시작 부분을 7C00h에 둔다
 2. 파티션 테이블을 읽어서 활성 테이블이 유일하게 하나만 있는지 검사한다. 
 3. 활성 테이블이 여러개이면 에러를 나타내고 정지한다.
 4. 활성 파티션 테이블이 유일하면 그 테이블에 있는 운영체제의 커널을 읽는다.
 5. 읽은 커널을 메모리에 적재하고 커널 부분으로 점프한다.
 6. 커널이 시작된다.

그 외에도 다음과 같은 일들이 필요할 경우가 있다.

 7. 보호모드로 진입할 필요가 있다. (커널에서 시작 할 수도있습니다.)
 8. 윈도우 NT계열을 부팅할때는 NT로더를 작동시켜야 한다.
 9. 리눅스에서 처럼 커널의 시작 부분과 부트로더의 끝부분의 기능이 유기적이어야 한다.
 
부트 로더는 자신이 메모리의 물리적인 주소 7c00h에 위치한다는 가정하게 실행되게 된다. 이는 바이오스가 시스템의 전기적인 검사를 마친후 EIP를 7c00h로 설정하고 자신의 일을 마치기 때문이다. 따라서 항상 이 위치는 변하지 않는다. 그 다음으로는 활성 파티션을 찾아야 하는데 이는 FDISK등을 사용하면 알 수 있는 내용이다. 부팅에 필요한 커널이 들어있는 파티션을 이야기하며 보통 윈도우에서는 C드라이브가 되고 리눅스는 /boot의 위치가 될 것이다. 
활성 파티션을 찾았으면 그 파티션에 커널이 존재하는 섹터들을 읽어서 메모리에 적재하고 그 메모리로 점프하면 부트로더의 임수는 끝나게 된다. 추가로 운영체제에 따라 보호모드로 전환하는 작업을 부트로더가 하거나 LILO등과 같이 여러 개의 커널을 선택하게 하는 기능을 붙이면 된다.

어셈러브에서 만든 단순한(?) 부트로더는 모든 기능들을 제외하고 활성 파티션을 찾아 활성 파티션에서 데이터 영역에서 처음의 두 섹터를 읽어 메모리로 로드하고 메시지를 출력하는 부분까지 제작하였다. 앞으로 커널을 제작하게 되면 커널 이미지가 압축되어있는지 어떤 위치에 저장되어있는지에 따라 추가된 기능들을 구현하기 위해서이다.

== Notice! ==
가장 주의할 점은 부트로더를 만들시에는 절대 주소만을 참조한다는 점이다. 부트로더를 바이너리 이미지로 MBR에 저장해야 하므로 .exe 파일로 만들어서 테스트를 한다면 디버깅시에는 잘 작동하지만 막상 부팅할 때 제대로 동작하지 않을 것이다. 때로는 제대로 된 문자열이 아니라 알 수 없는 문자열이 출력될 것이다. 메시지의 오프셋이 100h일 때 디버거를 사용해서 메시지를 출력해보면 200h 지점의 데이터를 출력할 것이다. 이는 바이너리 이미지를 만들기 위해서 .com 파일로 만들었기 때문인데 디버거는 자동으로 파일의 .exe 헤더를 붙여서 디버깅을 실행하게 된다. 따라서 오프셋 100h의 데이터를 출력하려해도 100h+100h의 값을 출력하게 된다. 이 점을 고려해서 디버깅을 해야한다.

만약 2000이나 XP같은 NT 계열에서 작업을 하신다면 컴파일이 안되거나 더버깅에서 오류가 나거나 프로그램이 멈추는 것을 경험할 것이다. 이것은 보호때문인데 우리가 읽거나 쓰려는 섹터는 모두 MBR이나 운영체제가 관리하는 부분이므로 INT 13h에서 보호 오류가 나거나 에러가 발생할 것이다. 가급적이면 98등 보호기능이 없는 버전에서 작업하거나 따로 도스등을 준비하는 것도 좋고 아니면 도스창이 아니라 도스 모드로 부팅해서 작업하길 권한다.

도스 인터럽트는 절대 사용할 수 없다. 오직 바이오스의 기능만을 사용해야 한다. 이는 아무런 운영체제가 실행되지 않은 상황에서 운영체제의 기능을 이용하려는 것이므로 당연한 이야기일 것이다.
또한 프로그램의 첫 시작이 중요한데 바이오스가 실행을 넘겼다고 해서 바로 우리의 프로그램이 실행된다고 가정해서는 안된다. 아마 이 부분 때문에 고민이 많을 것인데 프로그램의 시작 부분에 레이블을 지정하고 이 주소로 점프를 하는 기능이 필요하다. 소스를 보면 다음과 같은데

{{{
mov   ax, 7c0h
push  ax
mov   ax, offset start
push  ax
retf
start:  
}}}
 
부트로더는 리얼모드에서 프로그램을 실행시킬 것이므로 세그먼트:오프셋 주소를 사용하게 된다. 따라서 여기서는 세그먼트 주소를 7c0h로 지정하고 오프셋을 레이블의 주소로 지정했다. 원래는 이 부분이 없었는데 이상하게 우리가 만든 부트로더가 제대로 동작하지 않았다. 디버깅을 해봐도 프로그램의 시작 부분으로 진입하지 않았다. 그래서 이미 만들어진 부트로더 소스들을 참조해서 이 부분을 추가한 결과 정상적으로 동작하게 되었다. 그 이유는 아직도 잘 모르겠다.
부트로더는 MBR에 저장된다고 앞에서 말했다. 바이오스가 MBR을 읽고 지금 저장된 값들이 부트로더 프로그램인지 확인하고 메모리로 로드하기 위해서는 MBR의 마지막 위치에 두 바이트의 값을 써주어야 한다. 바이오스는 이 값을 읽고 정해진 값이 아닐때는 부팅이 불가능함을 알고 플로피 디스크를 읽거나 에러 메시지를 출력하는 것이다. 따라서 프로그램의 끝에 다음과 같은 부분이 필요하다.

{{{
db                  11ah    dup (?)
db                  55H, 0AAH
}}}

프로그램의 크기를 계산한 다음 섹터의 끝에 값을 쓰기위해서는 얼마나 떨어져야 하는지를 손으로 계산해야 한다. 우리의 부트로더에서는 11ah가 필요했고 그 다음에 55h과 aah를 적어주면 바이오스가 이를 읽고 MBR을 읽어서 실행을 넘기는 것이다. 뒤에 WINDOWS 95의 MBR을 보여줄텐데 거기에도 이 값들이 써진 것을 확인 할 수 있을 것이다.

== Source == 
이제 소스를 볼 것이다. 소스가 짧고 매우 단순하므로 부트로더가 해야하는 일들만 이해한다면 쉽게 이해할 수 있다.
 
{{{
CodeSeg	segment
	assume cs:CodeSeg, ds:CodeSeg, ss:CodeSeg
Main	proc
	; 리얼모드에서는 세그먼트:오프셋 주소를 사용하므로 7c00h가 아닌 7c0h 세그먼트 주소로 
	; 지정하고 오프셋은 시작하는 레이블의 주소로 한다.       
	mov   ax, 7c0h
	push  ax
	mov   ax, offset start
	push  ax
	retf
start:   
	; 이제야 부트로더가 시작된다.
	cli
	mov   ax, cs
	mov   ds, ax
	mov   es, ax
	mov   ss, ax            ; 모든 세그먼트 재설정 -> 없어도 된다.
	mov   sp, offset main   ; 스텍 포인터 변경
	sti
 
	;하드 디스크의 부트 섹터를 읽어서 메모리 0:1000h에 올립니다.
	xor ax, ax
	mov es, ax
	mov dx, 0080h            ; int 13h에서 필요한 데이터들은 레퍼런스를 참조한다.

	mov cx, 0001h
	mov ax, 0201h
	mov bx, 1000h
	int 13h

	;si에 부트 섹터의 시작지점이 들어갑니다.                    

	mov si, bx                 
	push si

	call FoundActive                   ;활성 드라이브를 찾습니다.


	cmp ax, 0                                       ;활성 드라이브를 못 찾았을때

	jz L_Error

	mov si, offset HDDmsg          ;활성 드라이브를 찾았을때

	call PrintMsg                        ;메세지를 출력하는 프로시저



	;다시 부트 섹터의 시작 지점을 로드합니다.

	pop si

	call LoadKernel                               ;커널을 로드합니다.
                     

	;활성 가능한 파티션이 없으면 에러메세지를 출력하고 멈춥니다.    

L_Error:

	mov si, offset PartError

	call PrintMsg

L_Hang:

	jmp L_Hang
                                
Main	endp
 
 
FoundActive	proc
	mov cx, 4                             ;4개의 테이블이 있다.
	add si, 1beh
                     
L_ReadTable:
	cmp cx, 0
	jz L_NotFound

	mov al, byte ptr es:[si]         ;테이블을 읽는다.
 

	cmp al, 80h                                               ;활성인지를 검사한다.

	jz L_Found                                                ;활성을 찾았다.
           

	;활성이 아니라면

	add si, 10h                                                ;다음 테이블을 읽기위해 10h를 더한다.

	dec cx

	cmp al, 00                                                 ;비활성이라면

	jz L_ReadTable                                          ;다음 테이블을 읽는다.
 

	;80h, 00h도 아니면 파티션 에러다.

L_NotFound:    

	mov ax, 0

	ret
 

L_Found:

	dec cx

	add si, 10h                                                

	mov al, byte ptr es:[si]         ;테이블을 읽는다.

	cmp al, 80h                                               ;활성인지를 검사한다.

	jz L_NotFound                                 ;또 활성이면 에러

	cmp al, 00                                                 

	jnz L_NotFound                                          ;80h, 00h도 아니면 에러다.

	cmp cx, 1                                                  ;마지막 테이블까지 읽었으면 끝낸다.

	jnz L_Found
 

	;활성 파티션이 하나이고 에러가 없을때

	mov ax, 0ffh

	ret
 
FoundActive	endp
 
;si에 들어있는 ascz 메세지를 읽어서 출력합니다.
;인자 : si
PrintMsg	proc

L_PrintChar:

	mov al, byte ptr cs:[si]

	cmp al, 0

	jz L_PM

	mov bx, 0007h

	mov ah, 0eh

	int 10h

	inc si

	jmp L_PrintChar

L_PM:

	ret                 
PrintMsg	endp
 
;부트 섹터에서 FAT를 읽어서 데이타 영역의 첫 섹터를 찾아
;0:0600h에 로드해서 점프합니다.
LoadKernel	proc
 

	xor ax, ax

	mov es, ax

	mov ax, 0201h

	add si, 1beh

	mov dx, word ptr es:[si]                  ;FAT의 1,2 바이트를 읽습니다.

	add si, 2

	mov cx, word ptr es:[si]                  ;FAT의 다음 두 바이트를 읽습니다.

	mov bx, 0600h

	int 13h
 

	;커널을 로드한 지점으로 점프합니다.

	xor ax, ax                 ;세그먼트 푸쉬

	push ax

	mov ax, 0600h ;오프셋 푸쉬

	push ax

	ret                                       ;점프?
LoadKernel     endp


HDDmsg		db       "Founded active HDD drive", 0                     

PartError	db       "Can't find active partition", 0
db	11ah    dup (?)
db	55H, 0AAH
CodeSeg		ends
                                end                          Main}}}

== References == 
사실 여기있는 소스와 설명으로는 너무나 부족한 점이 많다. 설명이 별로 자세하지도 않고 소스로 이해하기가 쉽지 않을 것이다. 이 문서의 목적은 어셈러브에서 제작한 부트로더의 설명에 있지 부트로더 자체에 대한 해설은 아니므로 그러한 부분들은 적지 않았다. 대신 다음의 문서들이 여러분에게 더 많은 지식을 안겨줄 것이다. 특시 OSRC 사이트는 꼭 둘러보도록 하자.


 * http://www.nondot.org/sabre/os/articles/TheBootProcess/

 

