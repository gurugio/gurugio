

[[TableOfContents]]

= Microsoft Macro Assembler = 

== 본 문서에 대해 ==
솔직히 강좌라고 하기에도 뭐하고 HOW-TO 문서라고 하기에도 부족합니다. 본격적인 내용도 없고 아주 기초적인 내용부터 탄탄하게 적지도 않을 것입니다. 제가 그렇게 경력이 많거나 실력이 좋지도 않고 다른 목적이 있어서 꼭 강좌라고 할정도록 자세하게 쓸 겨를도 없기 때문입니다. 

전 제가 어셈블리를 혼자 공부하던 몇 개월을 돌아볼 때 별로 중요하지 않은 것으로 시간을 보내고 작은 것으로 좌절하고 어려워했는지 알 수 있습니다. 그것은 지금도 어셈블리라는 언어아닌 이상한 것을 알고자 하시는 분들도 마찬가지라고 생각합니다. 질답 게시판에 올라오는 질문들이 반정도는 스스로 해답을 구하고자 노력하다가 자료도 없고 어디 물어볼 곳도 없어서 고생끝에 물어오는 것임을 알 수 있습니다. 저또한 그 답답함을 알기에 그 가려운 곳은 아주 조금은 해소해줄 수 있지 않을까 해서 적어보는 것입니다. 따라서 내용이 주로 책에는 잘 안나오거나 설명이 부실한 부분과 관련 자료가 거의 없는 윈도우즈에서의 어셈블리가 될 것입니다. 또 아주 기본적인 문법은 다루지 않을 것입니다. 그것들은 도스에서와 같기 때문입니다. mov 가 뭔지같은 명령어 설명이나 주소 지정이나 스택이 뭔지 같은 기본적으로 알아야 하는 문법들은 설명하지 않을 것이라는 이야기입니다. 그것들은 하나의 문서보다는 책을 통해 깊게 공부하시는 것이 절대적으로 좋을 것이라는 생각이고 또 제가 그것들을 하나하나 이해하기 쉽게 설명할 자신이 없기 때문입니다. 대신에 윈도우즈를 사용하는 지금에 맞게 도스에서 필요없는 내용과 윈도우즈에서 필요한 내용을 다룰 것입니다.

진행은 거의 순서에 상관없이 작은 주제들을 다루는 것으로 쓰여질 것이고 목표는 올해 상반기에 마무리 하는 것이지만 나중에 보강할 내용이 있다면 계속 보충할 것이므로 언제 끝날지에 대해서는 말할 수 없습니다. 단지 저 스스로의 즐거움을 위한 작업이므로 중간에 어설프게 끝내지만 않기를 바랄 뿐입니다.

간곡히 말씀드리지만 프로그래밍에 대해 정말 평생 즐기면서 죽도록 파고들고 싶은지 스스로 냉정하게 판단해보시기 바랍니다. 어셈블리라는 것은 언어가 아닙니다. 컴퓨터 아니 어떤 전자적인 신호를 사용하는 모든 시스템에 대해 알고자 할때 가장 기본이 되는 단계입니다. 그런 해커적인 마인드가 없이는 어셈블리의 문법은 외우고 사용할 수 있지만 결국 그것으로 끝나고 어셈블리의 마인드를 사용할 수 없을 것이라고 생각합니다. 외국에는 어셈블리를 아는 프로그래머들이 많고 또 대학이나 교육 기관에서 중요하게 다룬다고 합니다. 어셈블리로 프로젝트를 하는 곳은 아주 소수이지만 그 마인드를 알게되면 좀더 좋은 프로그래밍에 큰 도움이 되기 때문입니다. 어셈블리의 마인드를 뭐라고 설명할 수는 없지만 그 맛은 중독성을 가진다는 것은 확실히 알 수 있습니다. 

앞으로는 문서의 효율을 위해 높임말을 사용하지 않겠습니다. 또 가급적이면 말을 짧게 하고 주로 소스를 보는 방식으로 하겠습니다.

 1. 도스 환경의 내용은 최소한으로 하고 WIN32를 주로 다룬다.
 2. 우선 라이브러리의 예제를 가지고 코딩하는 연습을 하고 API를 다루는 것으로 넘어간다.
 3. 컴파일, 링크, 에디터와 디버거 사용을 다룬다.
 4. 기본 문법이나 명령어의 사용등은 설명하지 않는다.

== 대상 독자 == 
어셈블리가 어디에 쓰이고 왜 사용하는 지는 설명하지 않겠다. 또 누구에게 필요한 지도 설명할 필요가 없다고 본다. 어짜피 필요성이 없다고 생각하는 사람들이 이 강좌를 볼 리는 없을 것이고 일일이 그런 논쟁에 소모하고 싶지않다. 그리고 어셈블리의 기본 문법을 다루지는 않겠다. 시중에 아직도 어셈블리의 문법에 관한 책들이 많이 나와있고 그 책들처럼 자세하고 친절하게 설명할 자신도 시간도 없기 때문이다. 따라서 기본 문법을 알고 기초 서적을 한권정도는 읽어본 사람을 대상으로 한다. 또 윈도우즈 프로그래밍을 다룰 것이기 때문에 윈도우즈 프로그래밍에 대해 전혀 알지 못한다면 뒷장의 내용은 이해하기 힘들것이다. 하지만 어짜피 윈도우즈 프로그래밍의 기본 중에 기본만을 다룰 것이므로 처음에 감을 잡기가 힘들 뿐 조금만 익숙해지면 금세 익힐수 있을 것이다.

== 이제 DOS 는 잊자 ==
사실 도스가 뭔지 아는 사람도 요즘에는 별로 없을 것이다. 리눅스 프로그래머라면 이해할 것이지만 예전에는 도스라고 해서 순수 커맨드 입력방식의 운영체제가 있었다. 그 당시의 시스템에는 상당히 적당하고 쓸만한 프로그램이었고 또 즐거운 프로그램이었다. 운영체제가 거의 별일을 안하고 대부분을 프로그래머들이 직접 만들어야 했으니 어찌보면 프로그래머의 실력 발전에 상당히 기여한 좋은 채찍이었고 반대로 정말 후진 운영체제였다. 어쨌든 그 당시의 프로그래머들은 하드웨어의 거의 모든 부분을 다뤄야 했고 비디오의 출력도 직접 만들어야 했으니 그 당시 프로그래머라고 하면 지금의 개념과는 차원이 다르다. 아무나 하는 일이 아니었고 몇 년 배워서 되는 일도 아니었다고 전설로만 내려올 뿐이란다.

뭐 말이야 어쨌든 이제 도스는 없다. 도스에서 뭘 하든지 알 바도 아니고 이제 호환도 안되는 NT 계열의 윈도우즈가 대부분이므로 꼭 필요한 몇몇 부분을 제외하고는 알 필요도 없고 알 수도 없다. 따라서 이 강좌는 지금까지 도스에만 매달리고 명령어 사용법에 제한되던 어셈블리 강좌들에 이어서 윈도우즈즈에서의 사용법을 다루도록 하겠다. 사실 도스에서의 어셈블리나 대부분 같은 내용이고 API 호출이나 레지스터 사용들만 다르고 오히려 알아야 할 내용들이 더 적어지고 사용도 편해졌으니 이전에 하이텔등에 있던 주옥 같은 강좌들에 비해서는 내용이 많이 부실할 것이다. 정말 깊게 공부하고 싶다면 도스 시절의 어셈블리에 대해서도 같이 공부를 해야 한다는 것을 명심하자. 

도스에서 사용하던 도스가 제공하는 인터럽트나 하드웨어 제어 기능들은 이제 사용할 수 없다. 윈도우즈 API를 사용하면 된다. 굳이 느리고 호환도 되지 않는 도스 인터럽트를 사용할 필요가 없어졌다. 문자 하나를 출력하는 INT 21h 의 몇번 서비스니 하는 것들은 신경쓰지 않아도 된다. 정말 속 시원한 이야기가 아닐 수 없다. 그 수많은 인터럽트 리스트를 보면서 한숨 쉴 일이 없어진 것이다.

하지만 운영체제를 거치지 않는 하드웨어 제어등을 할 때는 좀 불편해졌다. 도스는 보호 모드를 사용하지 않으므로 직접 하드웨어를 다룰 수 있지만 윈도우즈는 그렇지 않다. API를 사용하지 않을 거면 직접 포트 제어를 해서 하드웨어를 다뤄야 한다. 이에 대해서는 설명하지 않겠다. 드라이버 제작을 목표로 하고 있지 않다면 알 필요도 없고 다루게 된다면 책 한권도 부족한 내용이므로 다룰 수도 없지만 말이다. 

결국 도스 인터럽트를 사용하던 것을 API를 사용하므로 정말 대단히 편리해졌다는 이야기이다. 또 나중에 알게되겠지만 도스 시절의 세그먼트 오프셋이 거의 필요가 없어졌다. 물론 윈도우즈도 세그먼트 오프셋의 개념을 사용한다. 하지만 도스 처럼 64K의 제한이 있는 것이 아니다. 이론상으로 4GB 의 주소 공간을 하나의 오프셋으로 사용하므로 DS나 ES를 사용해서 복잡하게 데이터를 접근하던 것을 하지 않아도 된다. 코드 세그먼트니 데이터 세그먼트니 하는 내용을 잠시는 잊어도 된다. 하지만 명심할 것은 윈도우즈의 내부에 깊게 들어가면 이 개념이 새로운 방식으로 다시 등장한다는 것이다. CPU의 주소 지정과 맞물려 보호 모드에서의 셀럭터라는 개념으로 등장하게 된다. 지금 당장은 세그먼트에 대해 전혀 신경쓸 필요가 없어졌다는 것만 알아두자.

여담이지만 나중에 VxD 를 다룰 일이 생긴다면 도스에 대한 내용을 미리 좀 공부해둘걸 하는 후회가 생길지도 모르겠다.

== MASM32 사용하기 ==
Masm은 윈도우즈용 어셈블러이다. 당연히 윈도우즈에서 어셈블리를 사용하려면 masm을 사용해야 한다. Nasm이나 fasm 같이 훌륭한 서드 파티 어셈블러가 있지만 윈도우즈 전용이 아니다. 또 masm은 대부분의 마이크로소프트사의 제품이 그러하듯이 편리한 기능이 넘치도록 많다. 오히려 기능이 많아서 프로그래머를 게으르게 한다는 말도 있을 정도이다. 개인적으로는 싫은 회사이지만 프로그래머에게 편하게 제품을 만든다는 것은 대단한 것이라고 생각한다.

=== Assembling ===
우선 masm32 패키지를 받아야 한다. 이 패키지는 어셈러브에 최신 버전을 올려놨으니 받아서 설치하면 된다. Masm 이라는 것은 Macro Assembler 라는 것으로 마이크로소프트사에서 윈도우즈용 어셈블러로 제작한 것이다. 이름이 말해주듯이 매크로 기능이 많고 그만큼 코딩하기 편하므로 상당히 널리 쓰이는 프로그램이다. 사실 어셈블러는 씨피유마다 다르고 인텔에서 사용되는 어셈블러도 종류가 상당히 많지만 마이크로소프트사의 특성상 서드 파티 제품들은 거의 멸종하고 없다.

패키지를 보면 하나의 실행파일로 되어있는데 실행만 하면 알아서 폴더를 만들고 몇가지 작업을 한다. 처음에 드라이브만 지정해주면 \masm32\ 라는 디렉토리가 생성된다. 여기에는 다양한 문서와 헬프 파일, 예제들이 있다. 특히 헬프 파일은 문법에 대한 설명이 레퍼런스 형식으로 되어있고 찾기 힘든 설명들도 많으므로 자주 이용하는 것이 좋다. 또 Icztutes 라는 디렉토리에는 윈도우즈프로그래밍에 대해 Iczelion 이라는 분이 쓰신 문서들이 있는데 이 문서만 보면 윈도우즈즈프로그래밍에 대해 거의 모든 것을 알 수 있다. 또 include 디렉토리와 m32lib 에는 꼭 필요한 파일들이 많다. 이름에서 알 수 있듯이 include 에는 헤더 파일들이 들어있고 m32lib에는 라이브러리로 쓸만한 작은 함수들이 들어있다.

우리가 처음에 사용할 것은 bin 디렉토리에 들어있는 ml와 link 이다. 이 파일들은 예전의 도스용 버전인 6.11 이하와는 완전히 다른 파일이다. link는 도스 시절의 어셈블리 소스를 컴파일할 때 사용할 수 없다. 도스 문법을 사용하는 소스를 컴파일 할때는 꼭 5.X 버전의 masm 패키지에 있는 link 를 사용해야 한다.

우선 ml 의 사용법을 알아보자. 여러가지 옵션이 있지만 다 알고있지도 않고 알고싶지도 않은 것이 사실이다. 본인이 아는 옵션은 c와 Zi 뿐이다.

일단 먼저 다음과 같이 입력한다.

C:\masm32\bin\ml /c /coff 파일이름.asm

그러면 파일이름.obj라는 오브젝트 파일이 생긴다. 이제 link를 사용한다.

C:\masm32\bin\link 파일이름.obj

이제 exe 파일이 생겼을 것이다. 중요한 것이 남았는데 VC로 디버깅을 할 수 있다는 것이다. 원래 masm은 DDK 에 속해있는 패키지였다. 따라서 VC에서 자유롭게 디버깅할 수 있다. 디버깅을 위해서 옵션을 추가해보면 이렇게 된다.

C:\MASM32\BIN\ml /c /coff /Zi 파일이름.asm

C:\MASM32\BIN\Link /SUBSYSTEM:WINDOWS /DEBUG 파일이름.obj

바로 Zi 옵션이 디버깅 정보를 추가하는 옵션이다. Ml의 도움말을 보면 금방 이해할 수 있을 것이다.
이해하기 쉽게 설정 화면을 캡춰해봤다.

=== DEBUGING ===
이제 디버깅을 하는 방법을 알아보자. 여러가지 방법이 있을 수 있다. 중요한 것은 VC에서 우리가 만든 실행 파일을 로드하면 된다. 

Microsoft Visual Studio\Common\MSDev98\Bin\MSDEV.EXE 파일이름.exe

이렇게 하거나 VC의 아이콘에 실행화일을 드래그하면 된다. 이렇게 해보면 VC가 실행되고 아무 창도 뜨지 않은 것을 알 수 있을 것이다. 디버깅을 시작하기 위해서 F10 이나 F11 을 누르면 된다. 그러면 소스창이 뜨면서 보통 VC에서 디버깅하는 방식과 같은 방법으로 디버깅 할 수 있다. VC에서 디버깅하는 방법을 아예 모른다면 보통 윈도우즈 프로그래밍 서적을 보면 자세히 나와있을 것이므로 알아두도록 한다.

=== EDITOR ===
Masm32 패키지에 있는 Q editor 를 사용하는 사람들이 많다. 이것도 매우 좋은 에디터임에는 분명하지만 사실상 사용하기에 불편한 점이 많다. 불편을 못 느낀다면 상관없지만 이왕이면 울트라 에디터라는 좋은 에디터를 사용해보길 권한다. 아니면 Acroeditor 라는 좋은 공개 에디터도 있다. 이 에디터들에서 어셈블링 하는 방법을 간단히 설명하겠다.

일단 울트라 에디터나 아크로 에디터는 사용자 도구를 설정할 수 있다. 여기에 컴파일러의 실행화일을 등록하고 소스의 이름을 등록하면 쉽게 단축키 하나로 어셈블과 링크를 실행할 수 있다.

간단히 본인의 울트라 에디터에서 설정한 내용을 적겠다. 울트라 에디터의 한글판을 실행하면 도움말에 자세한 내용이 나오므로 굳이 설명할 필요도 없을 것이다.

'''Ml을 위한 설정'''

명령줄 : C:\MASM32\BIN\ml.exe /c /coff /Zi "%f"

작업 디렉토리 : %P

'''link를 위한 설정'''

명령줄 : C:\MASM32\BIN\Link.exe /SUBSYSTEM:WINDOWS /DEBUG "%p%n".obj

작업 디렉토리 : %P

소문자 대문자에 따라 파일이름 지정하는 것이 다른데 소문자로 지정하면 8.3 제한을 넘길수가 있으므로 가급적 소문자로 지정하는 것이 좋을 것 같다. 참고로 디버깅도 에디터에서 바로 불러서 사용하기 위해 지정할 수 있다. 명령줄에  MSDEV.EXE %p%n.exe 로 입력하면 단축키 하나로 바로 VC를 불러서 디버깅 할 수 있게된다. 이 외에도 make 파일을 만들어 사용하는 방법이 있지만 에디터의 기능들이 풍부하므로 별로 사용하지 않는다. 
== SKELETON CODE ==
윈도우즈 어셈블리로 코딩하기 위해 가장 기본이 되는 매크로들의 사용법을 익혀야 한다. 일단 가장 기본적으로 알아야 하는 매크로들은 다음과 같다.

=== MACROS ===
'''INVOKE expression [,arguments]'''

invoke는 타입 검사와 파라미터 변환 및 어셈블리 언어 프로시져 호출을 수행한다. 이 매크로는 주어진 아큐먼트를 스택에 푸쉬한 다음 지정된 프로시저를 호출하고 복귀시에는 스택을 비운다. masm은 여기에 적힌대로 함수 인자들을 파싱하게 되는데 주어진 인자와 proto 매크로에서 적힌 인자와 형식이 맞지 않으면 에러를 발생시킨다. 스택에 넣을 때는 .model 에서 지정된 콜링 컨벤션에 따라 순서대로 푸쉬하게 된다. 도스 시절의 call 과 다른 점이 뭐냐 하면 고급 언어의 함수 호출과 같이 함수 선언이 필요하고 인자를 편리하게 전달할 수 있다는 것이다. 이 기능들은 masm이 invoke 의 문법대로 적어준 인자들을 읽고 call를 사용하는 문법으로 변환하기 때문에 가능한 것이다. 실제로 디버깅할때 invoke 가 어셈블리 코드로 변한것을 보면 call로 변환 된 것을 볼 수 있다. 예를 들면 이 코드가

{{{
invoke strlen, arg1, arg2
}}}

이렇게 변한다.

{{{
assembly :
	push arg2
	push arg1
	call strlen
}}}

=== PROC ===

'''label PROC [distance] [langtype] [visibility] [<prologuearg>][USES reglist] ,parameter [:tag]]... [LOCAL varlist] statements label ENDP'''

프로시저의 시작과 끝을 나타낸다. 인자와 사용하는 레지스터, 지역 변수를 지정하는데 사용한다. 보통 필자는 이렇게 사용한다.

{{{
strlen proc uses ecx, ebx ptr:dword

    <code>

strlen endp
}}}

proc와 endp 는 프로시저의 시작과 끝을 나타낸다는 것을 쉽게 알 수 있을 것이다. 그리고 uses 는 사용되는 레지스터를 지정한다. 여기서 주의할 것이 있는데 eax, edx를 제외한 모든 레지스터를 사용하려면 그 값을 보존해주어야 한다는 것이다. 쉽게 말해 eax, edx를 제외한 레지스터를 사용하려면 프로시저의 처음과 끝에 스택에 보존하는 명령어를 쓰던가 이렇게 uses를 사용해야 한다는 것이다. 왜 그러하냐면 윈도우즈가 그 레지스터들을 사용하기 때문이다. 즉 그 레지스터들을 보존하지 않고 프로시저가 끝나거나 API를 호출하던지 프로그램을 끝내면 윈도우즈가 오동작을 일으킬 수도 있다는 것이다. 또 관례적으로 프로시저의 반환값을 eax와 edx에 저장하므로 나머지 레지스터는 보존해줘야 다른 프로시저에서나 프로시저의 밖에서 다른 레지서트들을 마음대로 사용할 수 있는 것이다. 예를 들어

{{{
lea esi, string
invoke strlen, esi
}}}
 
이렇게 esi에 문자열의 포인터를 저장하고 함수를 호출했을 때 함수가 끝난후에도 우리는 esi에 계속 문자열의 포인터가 저장되어 있다고 생각할 수 있어야한다. 그렇지 않고 esi의 값이 깨진다면 함수가 끝날 때마다 계속 esi의 값을 다시 지정해야 하므로 더욱 번거러울 것이다. 반대로 함수 이전에 eax, edx에 저장했던 값들은 항상 바뀐다고 생각해야 한다. 

{{{
 lea eax, string
 invoke strlen, eax
}}}

여기서 eax에 문자열의 길이가 저장될 것이다. 따라서 함수를 호출 한 다음에는 eax,와 edx의 값이 함수의 반환값이 들어가기 때문에 보존되지 않는다. 어찌보면 하나의 관례라고 할 수가 있다. 지키고 싶지 않다면 따르지 않아도 좋지만 결국에는 골치아파지는 것이 관례이니까 따르는 것이 좋을 것이다. 그러므로 항상 사용하는 레지스터는 eax, edx를 제외하고는 uses 에 쓰도록 하자. 예를 들면 다음과 같다.

uses 를 사용한 코드

{{{
 strlen proc uses ecx ptr:dword
}}}

실제 어셈블되는 코드

{{{
 strlen proc ptr:dword
 push ecx
 ...
 pop ecx
}}}

=== PROTO ===

{{{
label PROTO [, [parameter]:tag]...
}}}

프로그램 내에서 프로시저의 포로토 타입을 만든다. 이러한 선언이 왜 필요하며 왜 쓰는지는 씨에서와 마찬가지이다. 예를 들면 다음과 같다.

 strlen proto :dword

 변수의 이름은 쓰지 않아도 좋고 타입은 꼭 적어야 한다.

=== include - includelib ===
헤더 파일과 라이브러리 파일을 지정한다. 헤더 파일은 알고있는 것과 같이 그 자리에 파일의 내용이 대치되어 들어가고 라이브러리 파일은 어셈블할때 링크된다. 실제로 보통 사용하는 코드는 다음과 같다.

{{{
.386

.model flat, stdcall

option casemap:none

include  \masm32\include\windows.inc

include  \masm32\include\kernel32.inc

include  \masm32\include\user32.inc

includelib \masm32\lib\user32.lib

includelib \masm32\lib\kernel32.lib

 

 

Main proto

 

.data

 

 

.data?

 

 

.code

start:

             Main proc

                           < 여기 우리의 코드가 들어간다 >

                           invoke ExitProcess,NULL

             Main 두에

             < 여기에 우리가 만든 함수들이 들어간다. >

end start
}}}
  
가장 위에는 .386 이라는 지시어가 있다. 이것은 사용할 명령어의 시피유를 알려준다. 80386 명령어를 사용한다는 뜻으로 286 시피유에서는 실행이 될 수 없다. 반대로 486 이상에서는 이상이 없겠다.

.model flat, stdcall 에서 .model 은 메모리 모델을 선택하는 것이다. 우리는 윈도우즈에서 사용하는 flat 메모리 모델을 사용할 것이고 함수 호출시에 콜링 컨벤션을 stdcall 로 지정했다. (콜링 컨벤션이 우리 말로 뭔지 도대체 알 수가 없다..) 이것은 윈도우즈를 기반으로 하려면 꼭 지켜야 하는 사항이다.

그 다음에는 include 가 있다. 파일 이름들을 보면 금새 무슨 파일인지 이해가 될 것이다. 우리가 앞으로 사용할 API 들의 헤더파일이다. 당장 각 파일들을 열어서 확인해 보면 금방 이해가 될 것이다. 또한 앞으로 API들을 사용하다보면 아주 가끔식 헤더 파일에 선언되지 않은 경우도 있을 것이다. 그럴때는 자신이 직접 선언문을 적어서 사용해야 한다.

일단 기본적으로 위의 5가지 파일은 항상 적어줘야 한다는 것만 알고 시작한다.

.data 는 아시다시피 초기화된 데이터이고 .data? 는 초기화 되지 않은 데이터를 적어준다. 두개의 차이는 실행화일에 미리 할당된 만큼의 메모리를 잡는 것이 차이가 된다. 두개에 각각 아무 크기나 배열을 잡아주고 실행화일의 크기를 비교해 보면 .data? 에는 아무리 큰 배열을 잡아도 실행화일의 크기가 변하지 않는데 .data 에는 컴파일 하는 시간도 느려지고 실행화일도 커지는 것을 볼 수 있다. 그와 같이 메모리 사용에도 차이가 있다. .data 는 _data 라는 이름의 세그먼트로 되고 .data? 는 _bss 가 된다. 

그 다음 .code 는 말 그대로 코드를 적는 곳이다. 씨에서 main 함수처럼 우리도 main 프로시저를 만들었고 main 프로시저의 종료를 나타내기 위해 invoke ExitProcess,NULL 를 사용했다. ExitProcess를 msdn 으로 확인해 보자. 그 외에 다른 방법으로는 종료되지 않는다. 도스처럼 인터럽트를 사용할 수도 없다. 적어도 내가 아는 한에서는 그렇다. 어셈블러는 코드의 시작점을 .code 로 인식한다. 

start: 와 end start 는 코드 부분의 시작과 끝을 나타내는 것이므로 절대 빼놓아서는 안된다. 그리고 end start 다음에는 뭘 적든지 상관이 없다. 어셈블러가 그 다음은 읽지 않는다. 따라서 end start 다음에 프로그램에 대한 설명을 적던가 뭔가를 써놓아도 전혀 지장이 없다.

main 프로시저 다음에 우리가 프로시저를 만들어서 적으면 된다.

대부분의 사람들이 씨를 처음 배울 때처럼 그냥 그런가부다 하고 일단 따라서 해보자. 금새 이해가 될 것이다. 일단 한동안은 위의 코드를 그대로 사용하는 것이 좋을 것 같다.

== Code Example - strlen ==
지금부터는 masm으로 프로그래밍을 하는 연습을 해볼 것이다. 어셈블리의 기본 문법만 알면 모두 이해할 수 있다. 어셈블리라고 하면 이상하게 겁을 먹거나 기계어처럼 복잡하고 시간만 낭비하는 삽질이라고 선입견을 가지는데 실제로 제대로 공부해본 사람이라면 그런 소리는 하지 않는다. 씨를 전혀 모르는 사람이 씨를 가지고 쓸데없이 복잡하다느니 요즘에도 쓰기는 하던가 라든지 말을 한다면 씨를 공부해본 사람들은 당연히 그 사람과는 상종도 안할 것이다. 어셈블리도 마찬가지이다. 기본 문법은 그 어떤 언어보다도 쉽다. 단지 코딩할때 라이브러리가 없으므로 프로그래머가 직접 라이브러리를 만들고 일일이 새롭게 만들어줘야 한다. 한개씩 라이브러리를 만들다보면 어느새 프로그램이 어떻게 돌아가는지 그 원리가 눈에 들어온다는 것을 느낄 것이다. 쉽지는 않다. 하지만 공짜로 얻어지는 것도 없다.

우선 가장 간단한 문자열의 길이를 알아내는 함수부터 만들어보겠다.

'''ASCII-ZERO string'''

ASCII ZERO 혹은 ASCZ 라고도 하는 문자열이 있는데 무엇이냐 하면 보통 쉽게 쓰는 널 (NULL) 문자로 끝나는 문자의 배열을 말하는 것이다. 예전에는 $ 로 문자열의 끝을 나타냈으므로 모든 문자열이 처음부터 널로 끝난다는 생각을 하지 말자. 예를 들면

"I am a BOY!"

이러한 문자열은 결국 문자의 배열이고 메모리의 값을 읽어보면

49h, 20h, 61h, 6dh, 20, 61, 20, 42, 4f, 59, 21, 0h

이렇게 0으로 끝난다는 뜻이다. 따라서 이런 문자열의 길이를 알아내기 위해서는 메모리의 값이 0인 바이트를 찾아내면 된다. 씨코드로 적어보면 이렇게 된다.

{{{
int strlen(const char *p)
{
char *ptr = p;

while (*ptr != NULL)
    ptr++

return (ptr – p);
}
}}}
 
카운트를 만들어서 루프 안에서 카운트를 증가시키는 방법도 있지만 시간 소모가 더 많으므로 보통 이렇게 하기도 한다.

이제 먼저 장에서 알아본 고급 문법을 가지고 함수를 만들어보자. 함수의 이름은 API와 겹치지 않게 바꾸겠다. 우선 함수의 선언은 다음과 같다.

StringLen proto :dword
 
함수의 정의를 알아보자.

StringLen proc A_szPtr:dword

 …

StringLen endp

여기서 A_dzPtr 이라는 포인터를 더블 워드로 지정하는 것은 32비트 시스템이기 때문이다. 당연한 말이지만 여담으로 말하자면 포인터와 인티저 타입은 윈도우즈에서는 32비트가 된다. 왜 win32 라고 하는지가 이 이유에서이다.

 그 다음에는 함수 코드를 쓴다.

 
{{{
StringLen            proc      A_szPtr:dword

mov eax, A_szPtr                          ; 포인터를 레지스터에 저장한다.

.while byte ptr [eax] != 0 ; 널 문자를 찾는다.
	inc eax
.endw

sub eax, A_szPtr                           ; 포인터의 차이가 문자의 갯수이다.
ret

StringLen            endp
}}}
 
도스 문법을 공부한 사람이라면 eax에 주소값을 저장한다는 것을 보고 이상하게 생각할 것이다. 하지만 윈도우즈에서는 esi, edi에만 주소값을 저장하는 것이 아니라 모든 레지스터에 주소값을 저장해서 주소 지정을 할 수 있다. 따라서 여기서는 esi를 사용하지 않고 바로 eax를 사용했다. 왜냐하면 esi를 사용하면 스택에 저장해야 하는데 굳이 스택을 사용할 필요가 없기 때문이다.

나머지는 도스 문법을 안다면 쉽게 이해할 수 있을 것이다. 여기서 몇가지 최적화에 관한 내용을 다뤄야 한다. 최적화에 가장 기본이 되면서 쉬운 것들을 몇가지 소개하겠다.

 1. 가능한 레지스터를 사용하고 메모리를 적게 참조한다.
 2. 지역 변수를 가능한 적게 사용한다.
 3. 가장 중요한 최적화는 명령어 몇개가 아니라 알고리즘의 개선이다.

역시 말할 필요도 없이 3번 사항이 가장 중요할 것이다. 지역 변수를 가능한 적게 사용하는 것과 eax, edx 외의 레지스터를 가능한 사용하지 않아서 스택의 접근을 줄이는 것은 같은 내용이다. 결국 메모리보다는 레지스터의 접근이 빠르므로 당연한 소리가 될 것이다. 하지만 굳이 몇시간씩 고민하면서 메모리 접근을 피할 필요는 없다. 펜티엄4가 나온 마당에 DDR 메모리를 사용하면서도 메모리 접근의 속도를 따질 필요는 없는 것이다. 생각나면 그렇게 하라는 것이고 굳이 고민할 필요는 없는 것이다. 하나의 습관으로 가진다면 편할 것이다.

사실 어셈블리로 코딩하면서 위의 소스처럼 코딩하면 상당히 깔끔한 편이다. 하지만 한가지 매우 중요한 것이 있다, 메모리의 읽고 쓰는 데에 중요한 명령어가 있기 때문이다. 여기서는 일일이 명령어를 설명하지는 않겠고 다음의 소스를 보고 해당 명령어를 찾아서 이해하기 바란다.

{{{
StringLen            proc      uses edi                          A_szPtr:dword

mov edi, A_szPtr                           ; 포인터를 레지스터에 저장한다.
mov edx, edi                                 ; 다른 레지스터에 복사해 둔다.
xor                      eax, eax 
repne    scasb                              ; 검색을 시작한다.

; 문자열의 길이   = 현재 주소         - 원래 주소         - 1(널문자)
dec edi                                         ; 먼저 edi를 감소시킨다.
sub        edi, edx                           ; 원래의 포인터를 뺀다.
mov       eax, edi 

ret

StringLen            endp
}}}
 
간단하게 설명하자면 scasb는 edi의 주소값에 있는 한 바이트를 읽어서 al의 값과 비교하는 것이고 repne 는 비교한 값이 같지 않으면 반복하는 것이다. 결국 al이 0이 들어있으므로 문자열에서 한 문자씩을 읽으면서 0과 비교해서 같은 값이 나올 때까지 읽고 비교하는 것이다. 또 scasb는 자동으로 edi 값을 읽고 증가시키므로 inc edi 로 포인터를 증가시킬 필요도 없다. 

중간에 dec edi 를 쓴 이유는 scasb 가 edi 를 증가시킨 다음에 비교를 하기 때문이다. 만약 0을 읽었다면 먼저 edi를 증가시켜서 널 문자의 다음 주소를 가리킨다음에 al 값과 비교를 해서 제로 플래그를 셋팅하고 루프를 탈출하기 때문에 바로 edi를 감소시킨다음에 원래 문자열의 시작 주소를 빼야 한다. 그래서 edx 에 복사해둔 시작 주소를 edi 에 뺀 것이다. 그리고 결과값의 반환을 위해 eax에 결과를 복사하면 끝나는 것이다.

눈으로 보기에는 나중의 소스가 스택도 사용하고 명령어도 훨씬 많이 쓰므로 더 느리게 보일 것이다. 하지만 결과를 비교해보면 엄청난 차이가 생긴다. 이것은 메모리의 하드웨어 적인 특성을 이용하기 때문이다. DRAM은 메모리의 값을 읽을 때마다 주소를 지정해주어야 했다. 즉 10개의 문자를 읽으려고 하면 10번 주소값을 전송해야 했다. 하지만 SRAM 부터는 그 시작 주소만 지정해주면 메모리가 알아서 그 다음 데이터들도 계속 보내준다. 따라서 문자열같이 연속된 메모리를 읽을 경우에는 이렇게 최적화된 명령어를 사용하는 것이 더 좋다. 예를 들면 메모리 복사나 메모리 초기화처럼 연속된 메모리를 다루는 API를 디스어셈블해보면 이러한 명령어들을 사용하는 것을 볼 수 있다. 그 외에도 버스트 모드라는 것을 이용하는데 이것은 이 문서의 주제에서 벗어나므로 다른 문서를 참조하도록 한다.

가장 짧은 함수를 만들어봤다. 물론 masm의 도스 문법에 익숙한 사람도 상당히 낯설고 이상해 보일 것이라는 것은 잘 안다. 하지만 이게 도스와 윈도우즈의 차이다. 최적화를 위해서 하드웨어적인 특성도 이해해야 하고 8086이 아닌 80486 이후의 새로운 명령어들을 사용해야 한다. 또 앞으로 32비트 레지스터와 16비트 레지스터의 사용법이 다른 것도 배워야 한다. 너무 서두르지 말자. 우선 이번 장에서 알아본 기초적인 최적화 방침과 고급 명령어를 이해하고 잘 이해가 안된다면 그냥 외워놓고 넘어가자. 자꾸 쓰다보면 어느샌가 익숙해 질 것이다. 씨를 배울 때를 돌이켜보면 처음에 이해가 안되던 것도 자꾸 쓰다보면 어느새 익숙해지고 이해가 되는 경우가 많았을 것이다. 포기만 하지 않는다면 곧 언제 그랬냐는 듯이 자유롭게 사용할 수 있을 것이다. 

'''주의 – 최적화'''

최적화라는 것이 원래부터가 말이 많다. 이게 맞다 저게 맞다 서로 중구난방으로 싸우는 것이 이 문제라고 생각된다. 하지만 별로 신경쓸 것은 없다. 명령어 몇개 줄인다거나 몇십번의 루프에서 명령어를 조금 바꾼다던가 하는 것으로는 최적화가 될리가 없기 때문이다. 또 예전 펜티엄 시절의 U/V 파이프라고 해서 레지스터의 접근을 떨어뜨려야 한다느니 뭐니 하는 소리도 있는데 그건 시피유에 파이프가 두개만 있을 때 하던 소리다. 요즘에는 몇개가 있는지 확실히 모르지만 여하튼 그런 식으로는 최적화가 될 턱이 없다는 것이다. 그러니 어찌보면 이렇게 길어야 천바이트 정도인 문자열을 다루는 함수에서 최적화를 이야기한다는 것 자체가 어불성설일 수도 있다. 하지만 위에서 이야기한 것들은 최적화 이기 전에 어셈블리로 코딩을 하는 좋은 습관이라고 할 수 있다. 외국의 소스들을 봐도 저 정도의 규칙은 지키는 것이 보통이다. 또 masm의 헬프 파일에 보면 코드 최적화라고 해서 몇가지 명령어들을 최적화 하는 방법이 있기도 한데 예전 시스템의 내용이라 그다지 신빙성이 없어보인다. 일단 최적화는 시피유의 특성과 메인 보드의 버스의 특성, 메모리의 특성등 하드웨어와 아주 밀접하게 연계되는 내용이니까 아직 그 분야에 대해서 다뤄보지 못했다면 일단은 참고 넘어가자. 나중에 기회가 된다면 최적화에 대해서만 한장을 다루는 것도 좋을 지 모르겠다. 어쨌든 결론은 문서를 쓰는 본인도 최적화라고 하면 골치만 아프고 생각하기도 싫다는 것이라는.. 것이었던.. 거시다.. 뭐..

그리고 정말 정말 중요한 것은 최적화는 경력이 많은 경험이 풍부한 분들이 주로 하시는 일이라는 것이다. 그러므로 경력이란 것도 없는 이 보잘것 없는 학생이 최적화라고 떠드는 것을 절대 믿어서도 따라해서도 안된다는 것이다. 개그는 개그일뿐 따라하지 말자~~

== Code Example - strcmp ==
 알다시피 strcmp 는 스트링을 비교하는 라이브러리이다. 앞에서 스트링의 길이를 구하는 함수를 만들었는데 여기서 아주 조금만 추가하면 되는 간단한 함수이다.

우선 익숙한 씨 코드로 구상을 해보자. 간단하게 생각하면 보통 다음과 같을 것이다.

{{{
int strcmp(char * src, char * dest)
{
	while (*src != NULL && *dest != NULL)
	{
		if (*src++ != *dest++) break;
	}

	return (*(--src) - *(--dest));
}
}}}

우선 두 문자열을 널문자까지 포인터를 증가시키면서 각 문자열의 문자를 비교해서 서로 같지 않으면 루프를 벗어나고 두 문자의 차이값을 반환하도록 한다. 또한 널문자까지 검사해서 모두 같아도 루프를 벗어나고 두 널문자의 차이를 반환한다. 결국 문자열이 같으면 0을 다르면 0이 아닌 값을 반환하게 된다. 이것이 보통의 씨 라이브러리 이지만 우리는 한가지 기능을 더 추가해서 원본 문자열에서 어떤 지점이 대상 문자열과 다른지를 알아내도록 하자. 최종 소스는 다음과 같게 된다.

{{{
char * strcmp2(char * src, char * dest)
{
	while (*src != NULL && *dest != NULL)
	{
		 if (*src++ != *dest++) break;
	}

	if (*src == NULL && *dest == NULL)
		return 0;
	else
		return --src;
}
}}}

이제 어셈블리 코드로 옮겨보자. 간단히 기본 명령어만을 사용해보면 다음과 같다.

{{{
StringCmp           proc      uses esi edi       A_szSrc:dword, A_szDest:dword
	
	mov esi, A_szSrc
	mov edi, A_szDest
	mov al, byte ptr [esi]
	mov dl, byte ptr [edi]
	
	.while (al != 0 && dl != 0)
		.if al != dl
			.break
		.endif
		esi
		inc edi
		mov al, byte ptr [esi]
		mov dl, byte ptr [edi]
	.endw

	.if (al == 0 && dl == 0)
		xor eax, eax
	.else
		mov eax, esi
	.endif

	ret

StringCmp           endp
}}}
 

약긴 지저분 하기는 하지만 그럭저럭 원하는 동작을 하는 함수가 만들어졌다. 하지만 이전 문서에서 처럼 좀더 고급 명령어를 쓰면 더 보기 좋은 소스가 될 것이다.

일단 한 바이트를 읽어들어서 비교하는 명령어가 있다. 바로 cmps 이다. 스트링 관련 명령어가 대부분 그러하듯이 변수 타입에 따라 몇가지가 있다. cmpsb, cmpsw, cmpsd 즉 바이트, 워드, 더블 워드 세종류가 된다. 결국 우리가 원하는 것은 cmpsb 가 된다. 그래서 이 명령어를 사용하는 함수로 고치면 위에서 한 문자를 읽고 비교하는 부분을 빼서 (루프 전체가 된다.) 이 명령어로 바꾸면 된다.

{{{
StringCmp           proc      uses esi edi ecx A_szSrc:dword, A_szDest:dword

	mov esi, A_szSrc
	mov edi, A_szDest

	StringLen, esi        ;원본 문자열의 길이를 알아낸다.
	inc eax                             ; 널문자를 비교하기 위해 하나 더한다.
	mov ecx, eax                   ; ecx에 들은 수 만큼 반복한다.

	repe cmpsb

	.if ZERO?                          ; 제로 플래그가 셋팅되었다면
		 xor eax, eax        ; 널문자까지 모든 문자가 같다는 뜻이다.
	.else
		mov eax, esi       ; 제로 플래그가 셋팅되지 않았다면
		dec eax              ; 문자가 서로 다르다는 것이다.
	.endif
	
	ret

StringCmp           endp
}}}
 
이제 감이 올지도 모르겠다. 이제부터 우리는 루프를 돌면서 메모리를 읽고 비교하거나 데이터를 저장하는 부분을 대부분 이러한 고급 명령어로 바꿀 것이다. 연속된 메모리라는 조건이 있지만 말이다. 그리고 비교할 때마다 위에서처럼 플래그를 이용할 것이다. 위의 소스를 설명하자면 우선 데이터를 몇번이나 읽을 것인지 카운터를 설정하기 위해 문자열의 길이를 알아내는 함수를 사용했다.

여기서 잠깐 rep 에 대해서 알아보자. rep는 말 그래도 repeat의 약자이다. 결국 어떤 명령어를 조건에 맞게 반복해주는 명령어가 된다. 뒤에 따라오는 스트링 멸영어의 실행을 ecx에 저장된 값 만큼 반복하게 된다. 

|| Repeat Prefix |||| Termination Condition1 |||| Termination Condition2 ||
|| rep |||| ecx = 0 |||| None ||
|| repe/repz |||| ecx = 0 |||| ZF = 0 ||
|| repne/repnz |||| ecx = 0 |||| ZF = 1 ||

결국 rep는 ecx의 카운터에 의해서 반복하는 것이고 repe는 제로 플래그가 1일 때만 반복, repne는 그 반대로 제로 플래그가 0일 때만 반복하는 것이다. 위의 표는 종료 조건이므로 그 반대로 repe는 제로 플래그가 0 즉 같지 않다면 종료되는 것이고 repne는 제로 플래그가 1 즉 같을 때 반복하는 것이다. e 는 equal 이고 ne 는 not equal 이므로 그 의미를 잘 생각해 보면 쉽게 알 수 있을 것이다. 

일단 모든 반복은 ecx에 의해서 최고 한계가 결정되고 그 다음으로 플래그에 의해서 중간에 멈출 수 있다는 것이다. 그리고 플래그를 사용해야 하는 repe/repne는 플래그를 설정하는 명령어인 cmps와 scas에 의해서만 사용되게 된다. 그 외에 다른 명령어의 반복은 항상 ecx를 설정해서 rep 를 사용해야 한다.

다시 예제 소스를 보면 repe cmpsb 를 사용한 것은 edi와 esi의 두 문자열을 비교하면서 같다면 다음 문자로 반복해서 비교하라는 것이다. 그래서 나중에 같지 않은 문자를 만나거나 ecx가 0이 되면 종료될 것이고 종료된 후에 제로 플래그가 셋팅되지 않아다면 같지 않은 문자를 만났다는 뜻이고 셋팅되었다면 끝가지 같은 문자였다는 의미가 된다. 그래서 제로 플래그를 검사해서 반환값을 설정한 것이다.

이번 문서에서는 플래그를 검사하는 매크로와 반복 명령어에 대해서 알아보았다. 우리가 보통 루프를 만들어서 사용하는 부분을 이러한 스트링 명령어의 반복으로 대치할 수 있다. 또 비교하는 명령을 사용할 때는 항상 플래그를 검사해봐야 한다는 것이다. 그러면 더 간단하게 결과를 검사해볼 수 있게 된다.

아직도 이해가 안된다면 기본적인 8086 명령어들을 사용해서 직접 함수를 만들어 본 후에 위에 예제 소스를 읽어보고 비교해보자. 그러면 어디서 어떤 명령어를 사용해야 하고 어떤 매크로를 사용해야 할지 알 수 있을 것이다.

다시 한번 말하지만 이제 어셈블리를 기계어처럼 사용하던 시대는 갔다. 그렇게 사용하는 방법도 알아야 하지만 일단 코딩에 효율을 높이기 위해서 매크로를 사용하는 연습을 하고 나중에 디버깅을 할 때나 드라이버를 만들 때 실제 어셈블리 코드를 읽는다면 훨씬 수월할 것이다. 또 고급 언어로 어플리케이션을 만들어서 디버깅을 할 때에도 어셈블리 코드를 보게 되는데 이때 8086 코드를 보는 것이 아니다. 예제 소스처럼 스트링 명령어라든지 펜티엄에서 최적화된 명령어를 보게 될 것이다. 그때 그 사용법을 모른다면 절대 디버깅할 수 없을 것이다. 우선 지금은 486이상의 명령어를 익히고 점차 펜티엄이나 MMX 같은 더 최근 시피유의 명령어를 익히도록 하자.

== Code Example - toupper, tolower ==

 이번 장에서는 문자열의 대소문자를 바꾸는 함수를 만들어보겠다. 그리고 아스키 코드의 특성을 약간 알아보겠다.

'''ASCII CODE'''

씨 프로그래머라면 벌써 알고있을 만한 아스키 코드의 특성에 대해서 간단히 이야기해보겠다. 우선 대소문자의 규칙이다. 대문자 A는 41h 이고 소문자 a 는 61h이다. 이것을 2진수로 바꿔보면 A는 0100 0001 이고 a는 0110 0001 이된다. 또 Z는 5Ah이고 z는 7Ah이므로 각각 0101 1010 이고 0111 1010 이 된다. 무슨 소리인가하면 바로 대문자에서 20h만 더하면 소문자가 된다는 것이고 그 20h가 바로 6번 비트라는 것이다. 결국 20h를 더하던가 6번 비트를 셋팅하면 소문자가 된다는 것이고 20h를 빼던가 6번 비트를 마스킹하면 대문자가 된다는 것이다. 

또 한가지가 있는데 1은 코드값이 31h이다. 결국 30h을 빼거나 4,5번 비트를 마스킹하면 된다는 것이다. 혹은 하위의 4바이트만을 빼다가 쓰면 된다.

'''CODE'''

이번 함수도 매우 간단하므로 바로 소스로 넘어가겠다. 일단 한문자씩을 읽는다. 그래서 목적에 따라 대문자인지 소문자인지를 검사해서 변환하면 된다. 먼저 toupper의 의사 코드로 써보면

한 문자 읽기

소문자인가?

예 – 대문자로 변환

아니 – 그냥 넘어간다.

다음 주소로 넘어간다.

이런 식이 되겠다. 비교하는 것도 없고 한문자씩 읽어서 처리를 해야 하므로 스트링 명령어를 사용하기가 힘들것 같다. 따라서 바로 코딩하면 된다.
 
{{{
 StringToupper                          proc                          A_szSrc:dword

	mov eax, A_szSrc
	mov dl, byte ptr [eax]

	 .while dl != 0
		.if dl >= ‘a’ && dl <= ‘z’
			xor dl, 20h                     ; 6번 비트를 마스킹
			mov byte ptr [eax], dl
		.endif
		
		inc eax
		mov dl, byte ptr [eax]
	.endw

StringToupper                          endp
}}}
 
반대로 소문자로 만드는 함수도 이와 똑같다. 단지 비트를 다루는 부분이 xor 이 아니라 or가 된다.

{{{
StringLower                          proc                          A_szSrc:dword

	mov eax, A_szSrc
	mov dl, byte ptr [eax]

	.while dl != 0
		 .if dl >= ‘a’ && dl <= ‘z’
			or dl, 20h                     ; 6번 비트를 마스킹
			mov byte ptr [eax], dl
		.endif
		
		inc eax
		mov dl, byte ptr [eax]
	.endw

 StringLower                          endp
}}}
 
아주 간단하다. 이것은 씨에 조금만 익숙한 사람이라면 쉽게 만들 수 있는 코드이다. 골치아프게 생각할 것이 없다. 참고로 대소문자를 한꺼번에 처리하는 함수를 소개한다. 이것은 옵션으로 0을 지정하면 toupper이 되고 1을 지정하면 tolower이 된다.

{{{
DtChangeStrCase     proc uses esi edi ecx A_ptrStr:dword, A_dwOption:dword 

	cld             
	 ; 원본             문자열의 길이를             받아 온다. ( eax = 원본          문자열의 값     )
	mov             esi, A_ptrStr 
	invoke DtGetStrLength ,           esi             
	mov             edi, esi 
	mov             ecx, A_dwOption             
	mov             eax, 1 

	.while al != 0 ; 문자열의 끝까지 
		lodsb                ; 한 바이트를 읽는다. 
		; 소문자일때만 (61h ~ 7ah) 대문자로 변환한다. 
		.if             ecx == 0 && al >= 61h && al <= 7ah 
			xor al, 20h           ; 5번 비트를 마스킹한다. 
		; 대문자일때만(41h ~ 5ah) 소문자로 변환한다. 
		.elseif ecx != 0 && al >= 41h && al <= 5ah   
			or al, 20h
		.endif

		stosb
	.endw 

ret

DtChangeStrCase     endp
}}}
 

어찌 보면 너무 간단해서 이거 정말 끝인가 하고 의아해 할지도 모르겠지만 본인은 이 이상 더 효율적으로 만들 수 있을지 모르겠다. 더 쥐어짤 부분이 있다면 직접 해보는 것도 좋겠지만 문자열 함수라는 것이 아주 큰 효율이 필요한 것은 아니므로 이정도로 끝내도 해도 좋을 것 같다.

== Code Example - strchr ==
이제 문자열 함수로는 마지막으로 문자열 내에서 원하는 문자열을 찾는 함수를 만들어보겠다. 이번 함수는 약간 길지만 역시나 그다지 어려운 부분은 없으므로 한줄 한줄 읽다보면 이해할 수 있을 것이다.

일단 어셈블리를 공부하려고 마음먹은 사람이라면 문자열 내에서 원하는 문자열을 찾는 함수를 씨나 다른 고급 언어로 만들어본 적이 있을 것이다. 경험이 없더라도 그다지 복잡하지 않은 내용이니 직접 생각해보도록 하자. 이렇게 원본 문자열 안에서 원하는 문자열이 있는지 검색하는 알고리즘은 상당히 많은 방식이 개발되었고 알고리즘 서적에 자주 등장하는 내용이다. 상당히 난해한 방식도 있고 더 빠른 방식도 있지만 사실 필자도 그것들을 잘 이해하지 못했고 이 문서는 알고리즘을 다루는 것이 목적이 아니므로 필자의 한계 내에서 만들 수 있는 소스를 가지고 이야기하겠다. 읽어보고 더 좋은 알고리즘을 생각했다면 직접 실습해 보는 것도 좋을 것 같다. 아마 상당히 많은 방법을 찾을 수 있을 것이다. 참고로 이 소스는 처음부터 필자가 만든 것이 아니고 프로젝트에서 같이 공부하는 최재영님께서 만드신 소스이다. 필자는 아무리 고민해도 이 이상의 코드를 만들 수가 없어서 대부분 그대로 참고하고 한두 줄만 고쳐봤다. 일단 소스부터 보자.

{{{
;========================================================================================== 
; 
;Name                  : DtSearchString
;Function              : 원본 문자열 안에서 특정 문자열을 찾아낸다.
;
;Parameter           : 1. A_szSrc:DWORD - 원본 문자열
;                              2. A_dwSrcLen:dword - 원본 버퍼의 길이 ( 원본 문자열의 길이가 아니다. 문자열이 담긴 버퍼의 길이이다.)
;                              3. A_szDest:DWORD - 찾을 문자열의 주소
;                              4. A_dwFindLen:dword - 찾을 문자열의 길이
;                              5. A_dwOption:Dword - 대소문자 구분 옵션
;
;Option                 : 0          : defult 대소문자 구분
;                            !0         ; 대소문자 구분   하지 않음
;
;Return Value       : 찾았으면 시작   주소를 반환
;Error                   : 못찾았으면 -1   
;
;==========================================================================================              

SearchString                    proc      uses ecx ebx edi esi       A_szSrc:Dword, A_dwSrcLen:dword, A_szDest:Dword,
                                                                                              A_dwDestLen:dword,A_dwOption:Dword
	mov esi, A_szSrc
	mov edi, A_szDest
	mov ecx, A_dwSrcLen
	cld                                                                           ; 문자열 읽는 방향 설정
	
	;-----------------------------------------------------------------------------------------------
	; 에러 체크 : 1. 원본 문자열이 찾을 문자열보다 길이가 작을 때
	;-----------------------------------------------------------------------------------------------
	mov edx, A_dwDestLen
	.if A_dwSrcLen >= edx
		; edx를 플래그로 사용한다.
		xor edx, edx
		.while ecx != 0
	
			;--------------------------------------------------
			; 원본 문자열과 목적 문자열에서 각각 한 글자씩을 읽는다.
			;--------------------------------------------------
			xor        eax,eax
			mov al, byte ptr [esi]
				.if  (A_dwOption != 0) && (al <= "z") && (al >="a" )      ; 대소 문자 구분 없이라는 옵션이 들어 갔을때
					sub        al,          20h                                   ; 대문자로 통일
				.endif
                                                    
			xor        ebx,ebx
			mov       bl, byte ptr[edi]  ; 비교   대상이 되는 값을 불러 들인다. 

				.if (A_dwOption != 0) && (bl <= "z") && ( bl >="a" )    ; 대소 문자 구분 없이라는 옵션이 들어 갔을때
					sub        bl,          20h                              ; 대문자로 통일
				.endif

			; 읽은 문자가 같다면 다음 문자들도 일치하는지 계속 검사해 나간다.
			.if           eax        == ebx
				mov edx, 1          ; mov tv_dwFlag, 1
				inc esi
				inc edi
				; 대상 문자열의 끝까지 일치한다면 찾은 문자열이 시작하는 포인터를 반환한다.
				.if byte ptr [edi] == 0
					mov eax, esi
					sub eax, A_dwDestLen
					.break
				.endif
			; 같은지 비교를 해 나가다가 중간에 다른 문자가 나왔을 때
			; 이때는 대상 문자열의 포인터를 되돌리고 원본 문자열은 비교한 문자부터 다시 비교한다.
			.elseif eax != ebx && edx != 0       ; tv_dwFlag != 0
				mov edi, A_szDest
				mov edx, 0                                    ;mov tv_dwFlag, 0
			; 서로 일치하지도 않고 비교하던 중도 아닐때
			; 이때는 대상 문자열의 포인터는 그대로이고 원본 문자열의 포인터만 증가시킨다.
			.else
				inc esi
			.endif
		
			dec       ecx
		.endw

		; 찾는 문자열이   없는 경우
		.if           ecx        == 0       
			mov       eax, -1
		.endif

		; 찾을 대상이 되는 문자열이 찾을 문자열보다 작을 경우는 검색 불필요 
	.else                                             ;.if (ecx >= eax ) && (A_dwSrcLen >= edx)
		mov       eax,-1 
	.endif
ret

SearchString                    endp
}}}

좀 엉성하다. 원래 최재영님께서 만드신 소스는 좀더 깔끔하지만 필자가 설명하기 쉽게 하려고 좀 고쳐보았다. 여담이지만 어셈블리 소스는 난해할수록 성능이 좋은 것들이 자주 있는 것같다. 

처음에는 역시 두 문자열의 포인터를 받아서 원본 문자열을 한 문자씩 읽으면서 대상 문자열의 처음 문자와 같은 문자를 찾는다. “abcdefg” 가 원본 문자이고 “cde”가 찾고자 하는 문자열이라면 일단 원본 문자열의 한 글자씩 a, b, c 이런 순서로 읽으면서 대상 문자열의 첫 문자인 c와 같은 문자를 찾는다. 그래서 같은 문자가 나오면 둘 다 다음 문자로 넘어가서 같은지를 검사하고 만약 같다면 대상 문자열이 널 문자를 만날때까지 검사한다. 또 서로 다르다면 대상 문자열의 포인터를 다시 시작 점으로 되돌려서 원본 문자열의 검색하던 지점부터 계속 비교해나간다.

좀더 예를 들어보면

“1234abcdcdeefg”

“cde”

이렇게 원본 문자열과 대상 문자열이 있다면 처음에는

“1” “234abcdcdeefg”

“c” “de”

이렇게 한 문자씩 검사한다. 그래서 원본 문자열의 포인터만 증가시키면서 검사해나간다.

“1” ”2” “3” “4” “a” “b” “c” dcdeefg”

“c” “de”

이렇게 원본 문자열을 하나씩 “c”와 같은 문자가 있는지 비교해 나가다가 원본 문자열에서도 “c”를 만나면 이때부터는 두 문자열의 포인터를 모두 증가시켜 나가서 문자열 전체를 비교하기 시작한다.

“1” ”2” “3” “4” “a” “b” “c” “d” “c” “deefg”

“c” “d” “e”

이 경우에는 대상 문자열의 마지막 문자 “e”와 원본 문자열의 “c”가 같지 않으므로 대상 문자열의 포인터를 다시 시작점으로 되돌린다. 이렇게 된다. 또 원본 문자열의 포인터는 계속 증가해 나간다.

“1” ”2” “3” “4” “a” “b” “c” “d” “c” “deefg”

“c” “de”

이제 다시 두 문자가 같으니 비교해 나가면

“1” ”2” “3” “4” “a” “b” “c” “d” “c” “d” “e” “efg”

“c” “d” “e”

대상 문자열의 널 문자를 만날때까지 그 문자열이 같으므로 일치하는 문자열을 찾게 되었다.

위의 소스에서 지역 변수로 플래그를 사용했다가 지웠는데 이는 edx를 대신 플래그로 사용했기 때문이다. 이렇게 지역 변수하나도 안쓰려고 쥐어짜는 필자를 보고 친구들은 소심하고 쪼잔하다고 하지만 맞는 말이므로 반박할 수가 없었다.

플래그를 왜 사용했냐면 처음에 대상 문자열의 첫 문자를 찾는 것과 첫 문자가 같아서 그 다음 문자들을 비교하는 것과 포인터를 증가시키는 것이 다르기 때문이었다. 전자의 경우에는 원본 문자열의 포인터만을 증가시키지만 후자의 경우에는 둘 다 증가시켜야 하고 또 비교하다가 중간에 같이 않은 문자를 만났다면 대상 문자열의 포인터는 다시 되돌려야 하지만 원본 문자열은 그 비교한 문자부터 다시 검사해야 하므로 그냥 놔두어야 한다. 필자는 이렇게 세가지 경우로 나누어서 생각해보았는데 여러분은 더 좋은 생각이 있을 걸로 믿는다. 하지만 이 소심한 성격에도 그냥 넘어가는 것은 이렇게 자주 않쓰거나 대용량의 처리를 하지 않는 문자열 함수는 어느정도 안정성만 보장되면 성능은 좀 떨어져도 상관이 없다는 판단에서이다. 차라리 메모리 처리나 파일 처리에서 좀더 쥐어짜는 것이 더 성능을 올릴 수 있지 않을 까 하고 생각해본다.

이 소스도 마찬가지로 꼭 이런 방식으로 따라 할 필요는 없다. 나름대로 익숙한 고급 언어를 사용해서 먼저 짜본다음에 아니면 의사 코드로라도 생각해봐서 그대로 어셈블리 코드로 옮기는 것을 연습해보자. 고급 언어와 유사한 구조의 매크로가 많으므로 이것들을 사용하는 것이 조금만 손에 익는다면 고급 언어를 조금만 수정해서 어셈블리 코드로 바꿀 수 있게 될 것이다. 또 그렇게 익숙해지면 나중에는 매크로없이 어셈블된 코드들만 가지고도 쉽게 이해할 수 있게 될 것이다.

이제 문자열 관련 함수들을 만들면서 연습하는 것은 끝내기로 한다. 이 정도면 자주 사용하는 매크로들도 다 설명했고 어느정도 뼈대는 익힐 수 있기 때문이다. 명심할 것은 한번 발명된 바퀴를 다시 발명할 필요는 없다는 것이다. 굳이 모든 라이브러리를 어셈블리 코드로 만들려고 할 필요도 없다. 특히 필자처럼 어셈블리 언어로 프로젝트를 진행할 경우가 아니라면 이렇게 몇 개만 연습해서 사용법을 알아두는 정도면 족할 것 같다. 이제는 API를 사용하는 것으로 넘어가보자. 다음 문서에서는 기본적인 API들을 호출해 볼 것인데 윈도우즈 프로그래밍 중에 sdk만으로 프로그래밍을 해봤다면 한눈에 알아볼 수 있을 것이다. 또 그렇지 않더라고 invoke로 API를 호출하는 것이므로 sdk 프로그래밍을 같이 공부해 나간다면 어셈블리를 사용하는 데는 어려움이 없을 것이다. 단지 sdk 프로그래밍 자체가 번거로운게 많아서 배우는 것이 시간이 걸릴 것이겠지만 그것도 처음에 몇 단계 뿐일 것이다.

== Win32 Assembly ==

이제 마지막으로 윈도우즈의 API를 사용하는 것을 작성해보겠다. 단지 지금까지는 우리가 만든 함수를 호출했는데 이제는 완전히 같은 방식으로 API를 호출하면 되니까 별로 추가로 다룰 내용이 없다. 단지 몇가지 주의 사항과 방식을 익히고 기본적인 예제를 몇가지 보면 그 다음에는 본인이 필요한 API를 알아서 호출하고 프로그램을 만들면 된다.

기본적으로 주의해야 할 사항이 있다. 지금까지 사용했던 것처럼 레지스터 사용을 주의해야 한다는 것이다. 특히 esi, edi, ebp, ebx 는 윈도우즈가 내부적으로 사용하는 레지스터이므로 절대로 파괴되지 않도록 해야한다. 어짜피 지금까지 eax, edx를 제외한 모든 레지스터를 보호하도록 연습해왔으므로 계속 이런 방식을 사용하면 될 것 같다. 그 이유는 윈도우즈가 콜벡함수를 사용하기 때문이다. 우리가 만든 콜벡 함수에서 위의 레지스터들을 변경하면 윈도우즈가 메세지를 받아서 우리의 콜벡 함수를 호출하고 다시 윈도우즈가 제어권을 넘겨받을 때 문제가 생긴다는 것이다. 그럼 예제 소스를 보도록 하자. 참고로 이제부터 볼 예제들은 masm32 디렉토리안에 있는 ICZTUTES 디렉토리에 들어있는 예제들이다. 각 디렉토리마다 실행파일도 같이 있으므로 실행해보면 더 이해가 잘 될것이다.

가장 먼저 간단한 예로 메세지 박스를 출력해 보도록 하자. 일단 메세지 박스의 API는 다음과 같다.

{{{
 int MessageBox(
  HWND hWnd,          // handle of owner window
  LPCTSTR lpText,     // address of text in message box
  LPCTSTR lpCaption,  // address of title of message box
  UINT uType          // style of message box
);
}}}

이 API를 호출하는 예제이다.

{{{.386

.model flat, stdcall

option casemap:none

include \masm32\include\windows.inc

include \masm32\include\kernel32.inc

include \masm32\include\user32.inc

includelib \masm32\lib\user32.lib

includelib \masm32\lib\kernel32.lib

 

.data

MsgCaption      db "Iczelion's tutorial no.2",0

MsgBoxText      db "Win32 Assembly is Great!",0

 

.code

start:

             invoke MessageBox, NULL,addr MsgBoxText, addr MsgCaption, MB_OK

             invoke ExitProcess,NULL

end start
}}}

다른 부분은 모두 스켈레톤 소스와 같다. 그리고 API를 호출하는 방식도 지금까지 우리가 함수를 만들어서 호출하는 것과 같다. 각 인자를 지정하고 주소를 전달할때는 addr 매크로를 사용하는 것까지 모두 같다. 일단 MessageBos의 각 인자를 살펴보면 처음에 윈도우의 핸들을 지정하는 인자에서는 널을 지정했고 메세지 박스의 메세지는 MsgBoxText를 메세지 박스의 캡션에는 MsgCaption을 지정했다. 또 마지막으로 스타일에는 VC에서 사용하던 것과 마찬가지 상수인 MB_OK를 지정했다. 이 상수도 위에서 선언한 헤더파일에 들어있다.

이렇게 보면 대부분 눈치챘을 것이다. 단지 함수들이 API인것 뿐이고 이전에 코딩하던대로 만들면 되는 것이다. 다음에는 윈도우 메인 함수와 콜벡 함수를 만드는 것의 예제를 보자.

{{{
.386 

.model flat,stdcall 

option casemap:none 

include \masm32\include\windows.inc 

include \masm32\include\user32.inc 

includelib \masm32\lib\user32.lib            ; calls to functions in user32.lib and kernel32.lib 

include \masm32\include\kernel32.inc 

includelib \masm32\lib\kernel32.lib 

WinMain proto :DWORD,:DWORD,:DWORD,:DWORD 

 

.DATA                     ; initialized data 

ClassName db "SimpleWinClass",0        ; the name of our window class 

AppName db "Our First Window",0        ; the name of our window 

 

.DATA?                ; Uninitialized data 

hInstance HINSTANCE ?        ; Instance handle of our program 

CommandLine LPSTR ? 

.CODE                ; Here begins our code 

start: 

invoke GetModuleHandle, NULL            ; get the instance handle of our program. 

                                             ; Under Win32, hmodule==hinstance mov hInstance,eax 

mov hInstance,eax 

invoke GetCommandLine                       ; get the command line. You don't have to call this function IF 

                                                 ; your program doesn't process the command line. 

mov CommandLine,eax 

invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT        ; call the main function 

invoke ExitProcess, eax                           ; quit our program. The exit code is returned in eax from WinMain. 

 

WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD 

    LOCAL wc:WNDCLASSEX                            ; create local variables on stack 

    LOCAL msg:MSG 

    LOCAL hwnd:HWND 

 

    mov   wc.cbSize,SIZEOF WNDCLASSEX                   ; fill values in members of wc 

    mov   wc.style, CS_HREDRAW or CS_VREDRAW 

    mov   wc.lpfnWndProc, OFFSET WndProc 

    mov   wc.cbClsExtra,NULL 

    mov   wc.cbWndExtra,NULL 

    push  hInstance 

    pop   wc.hInstance 

    mov   wc.hbrBackground,COLOR_WINDOW+1 

    mov   wc.lpszMenuName,NULL 

    mov   wc.lpszClassName,OFFSET ClassName 

    invoke LoadIcon,NULL,IDI_APPLICATION 

    mov   wc.hIcon,eax 

    mov   wc.hIconSm,eax 

    invoke LoadCursor,NULL,IDC_ARROW 

    mov   wc.hCursor,eax 

    invoke RegisterClassEx, addr wc                       ; register our window class 

    invoke CreateWindowEx,NULL,\ 

                ADDR ClassName,\ 

                ADDR AppName,\ 

                WS_OVERLAPPEDWINDOW,\ 

                CW_USEDEFAULT,\ 

                CW_USEDEFAULT,\ 

                CW_USEDEFAULT,\ 

                CW_USEDEFAULT,\ 

                NULL,\ 

                NULL,\ 

                hInst,\ 

                NULL 

    mov   hwnd,eax 

    invoke ShowWindow, hwnd,CmdShow               ; display our window on desktop 

    invoke UpdateWindow, hwnd                                 ; refresh the client area 

 

    .WHILE TRUE                                                         ; Enter message loop 

                invoke GetMessage, ADDR msg,NULL,0,0 

                .BREAK .IF (!eax) 

                invoke TranslateMessage, ADDR msg 

                invoke DispatchMessage, ADDR msg 

   .ENDW 

    mov     eax,msg.wParam                                            ; return exit code in eax 

    ret 

WinMain endp 

 

WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM 

    .IF uMsg==WM_DESTROY                           ; if the user closes our window 

        invoke PostQuitMessage,NULL             ; quit our application 

    .ELSE 

        invoke DefWindowProc,hWnd,uMsg,wParam,lParam     ; Default message processing 

        ret 

    .ENDIF 

    xor eax,eax 

    ret 

WndProc endp 

 

end start 
}}}

VC 에서 사용하는 기본적인 윈도우 생성 함수와 WndProc 함수이다. 기본 골격이나 사용하는 함수들은 대부분 같다. 중간에 무한 루프를 돌면서 메세지를 받고 처리하는 것도 같고 각 함수들의 인자도 VC와 같다. 대신 코드 세그먼트의 처음에 WinMain을 호출하는 부분이 있는데 아마 VC에서는 이런 부분이 없는 것같다. 

필자는 씨로 VC에서 sdk 프로그래밍을 해본 것이 작년에 며칠 뿐이라 거의 기억이 나지 않는다. 또 사실 위에 WinMain은 대부분 책에서 복사해서 그냥 쓰기만 해서 어떤 구조로 되어있는지 잘 모른다. 단지 대충 흐름만 알고있을 뿐이다. 그래서 더 이상 API를 사용하는 예제를 설명하거나 해석할 수 없다. 하지만 다른 좋은 문서가 있다. 

http://win32asm.cjb.net/

위의 주소는 Iczelion 이라는 분께서 윈도우즈에서 사용하는 어셈블리에 관한 거의 대부분의 주제에 관해 설명을 하신 사이트이다. 어셈러브에 있는 VxD 문서를 번역한 것도 여기의 문서를 번역한 것이다. 이분이 바로 masm32 패키지에 있는 ICZTUTES 디렉토리의 예제들을 만드신 분이시다. 이 문서를 읽고 계속 연구해보고 싶으신 분께서는 이 사이트를 찾아가셔서 여러가지 문서를 읽어보시면 아주 많은 것을 공부하실 수 있을 것이다. 그럼 행운을 빌겠다.

''See You Space...Cowboy..  (In Cowboy BeBob..)''
