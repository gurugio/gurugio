
'''64비트-SMP 커널 만들기 - 5장 부팅단계 임시 메모리 관리'''


----

 * 작성자: 김기오 
 
 * 문서 소개
64비트-SMP 커널 만들기 강좌의 5장

----

 * 작성 일지

2009.2.26 김기오: 작성 시작


----

[[TableOfContents]] 

----

= 부팅단계 임시 메모리 관리 =


부팅 단계에서 디스크립터 테이블이나 페이지 관리 테이블 등을 만들기 위해 임시로 사용될 메모리 관리 기능을 구현한다. 동적 메모리 관리가 필요하지 않으므로 비어있는 메모리 영역에서 요청된 페이지 크기만큼 순서대로 페이지를 할당해주고 나중에 진짜 메모리 관리 기능이 구현될 때 사용중인 메모리 영역을 알려주는 기능만 구현한다.


== 부팅 메모리로 할당되는 물리 메모리 영역 ==


부팅 메모리로 사용될 메모리 영역은 page.c 파일의 bootmem_init 함수에서 설정된다. PC의 물리 메모리는 과거 8086의 영향으로 사실상 0~1MB 영역과 1MB 이후 영역으로 나눠진다. 1MB 이전 영역에는 0~8K 영역에는 바이오스의 인터럽트 벡터나 하드웨어 관련 데이터가 저장되고 640K~1MB 영역에는 바이오스 데이터와 비디오 메모리 등이 있으므로 1MB 이하 영역은 동적으로 활용하기가 어렵다. 따라서 커널의 부팅 단계에서는 1MB 이후 영역을 주로 사용한다. 가장 먼저 커널의 이미지가 1MB에 맞춰서 저장되므로 그 이후 영역이 동적으로 활용할 수 있는 영역이 된다.

커널 이미지의 크기는 코드 구현에 따라 달라진다. 하지만 현재 CaOS 구현에서 커널이 사용할 스택 영역을 물리 메모리 2MB 지점으로 설정한다. 이것은 커널 이미지가 아무리 커진다 해도 1MB보다 작을 것이라는 가정을 하기 때문이다. 커널 이미지는 물리 메모리 1MB 지점부터 하위 방향으로 저장되고, 스택은 2MB 지점부터 상위 방향으로 저장된다. 추후에 커널 코드가 많아지고 이미지가 커진다면 스택을 4MB 지점으로 변경할 수도 있다. 커널의 스택이 시작되는 지점이 곧 커널 이미지가 끝나는 지점이므로 2MB 지점의 하위 메모리가 부팅 메모리 영역으로 사용된다. 부팅 메모리는 물리 페이지 프레임 단위로만 할당된다. 

setup.asm에서 페이징을 설정하면서 디폴트로 물리메모리 8MB를 사용할 수 있는 페이지 테이블을 만들었으므로 부팅 메모리 할당은 최대 8MB 크기까지 할당해줄 수 있다. 커널이 다시 전체 물리 메모리에 대한 페이지 테이블을 만들고 페이징을 다시 활성화할 때까지는 8MB의 메모리만 사용할 수 있다. 반대로 CaOS는 물리 메모리가 8MB 이상이 되어야만 실행이 가능해진다. 커널의 부팅 초기에만 사용할 메모리이므로 8MB 크기는 충분하다.

다음 3개의 변수가 부팅 단계에서 할당된 메모리를 관리한다.

 * bootmem_page_start: 부팅 메모리 할당 영역의 첫 페이지, 예를 들어 커널 스택이 물리메모리 2MB 지점이라면 이 변수의 값은 0x200 이 된다.
 * bootmem_page_index: 현재 할당 가능한 페이지의 번호
 * bootmem_page_max: 할당 가능한 마지막 페이지의 번호


== 부팅 메모리 할당 ==


부팅용 메모리 할당은 매우 단순한 방법으로 구현된다. 부팅용 메모리 할당을 받는 경우는 커널이 부팅하면서 전역적으로 사용할 데이터를 저장하는 것이므로 동적으로 할당되고 해지될 메모리가 아니다. 또한 데이터의 크기가 큰 경우가 많으므로 바이트 단위로 처리할 필요없이 페이지 단위로 할당한다. 따라서 alloc_bootmem 이라는 함수 하나를 이용해서 요청한 갯수만큼 페이지를 할당해준다. 현재 할당가능한 페이지 번호 bootmem_page_index를 가상 주소로 바꿔서 반환하고 bootmem_page_index에 할당된 페이지 갯수를 더해준다.


== 물리 메모리 주소와 가상 메모리 주소의 변환 ==

커널 영역에서 시스템의 모든 물리 메모리는 가상 메모리 0xFFFF_8000_0000_0000 으로 매핑된다. 따라서 물리 메모리 주소 값에 0xFFFF_8000_0000_0000 을 더하면 가상 메모리 주소가 되고, 반대로 가상 메모리 주소 값에서 0xFFFF_8000_0000_0000를 빼면 물리 메모리 주소가 된다. 이 것을 다음과 같이 매크로로 정의해서 사용한다.

{{{
 73 //
 74 // Physical address <-> Virtual address
 75 //
 76 #define __pa(x)         ((unsigned long long)(x)-PAGE_OFFSET)
 77 #define __va(x)         ((void *)((unsigned long long)(x)+PAGE_OFFSET))
}}}

이렇게 물리 메모리와 가상 메모리를 선형적으로 매핑하는 것은 커널 영역에서 물리 메모리 전체를 접근하기 쉽도록 하기 위해서이다. 사용자 프로세스를 생성할 때는 물리 메모리에 직접 접근할 필요도 없고, 접근할 수 있게 해서도 안되므로 이렇게 선형적으로 매핑하지 않고 동적으로 메모리를 할당해서 매핑하므로 이런 매크로를 사용할 수 없다.


== 참고 자료 ==






